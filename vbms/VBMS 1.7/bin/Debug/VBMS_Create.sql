/*
Deployment script for VBMS

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "VBMS"
:setvar DefaultFilePrefix "VBMS"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)] COLLATE SQL_Latin1_General_CP1_CS_AS
GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY SIMPLE,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY CHECKSUM,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = ALL, DATA_FLUSH_INTERVAL_SECONDS = 900, INTERVAL_LENGTH_MINUTES = 60, MAX_PLANS_PER_QUERY = 200, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE = OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET TEMPORAL_HISTORY_RETENTION ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'disable';


GO
PRINT N'Creating [dbo].[DBCCChecksLog]...';


GO
CREATE TABLE [dbo].[DBCCChecksLog] (
    [rec_id]         INT              IDENTITY (1, 1) NOT NULL,
    [execution_guid] UNIQUEIDENTIFIER NULL,
    [log_date]       DATETIME         NULL,
    [error_num]      SMALLINT         NULL,
    [level]          TINYINT          NULL,
    [State]          TINYINT          NULL,
    [message_text]   VARCHAR (500)    NULL,
    [repair_level]   VARCHAR (40)     NULL,
    [status]         TINYINT          NULL,
    [database_id]    SMALLINT         NULL,
    [db_frag_id]     INT              NULL,
    [object_id]      INT              NULL,
    [index_id]       INT              NULL,
    [partition_id]   BIGINT           NULL,
    [alloc_unit_id]  BIGINT           NULL,
    [rid_db_id]      INT              NULL,
    [rid_pru_id]     INT              NULL,
    [file]           INT              NULL,
    [page]           INT              NULL,
    [slot]           INT              NULL,
    [ref_db_id]      INT              NULL,
    [ref_pru_id]     INT              NULL,
    [ref_file]       INT              NULL,
    [ref_page]       INT              NULL,
    [ref_slot]       INT              NULL,
    [allocation]     INT              NULL,
    PRIMARY KEY CLUSTERED ([rec_id] ASC) ON [PRIMARY]
) ON [PRIMARY];


GO
PRINT N'Creating [dbo].[Blacklist]...';


GO
CREATE TABLE [dbo].[Blacklist] (
    [item_id]        BIGINT         IDENTITY (1, 1) NOT NULL,
    [date_added]     DATETIME       NOT NULL,
    [database_id]    INT            NOT NULL,
    [table_id]       INT            NULL,
    [index_id]       INT            NULL,
    [partition_n]    INT            NULL,
    [subsystem_id]   INT            NULL,
    [action_type_id] INT            NULL,
    [enabled]        BIT            NOT NULL,
    [worker_name]    NVARCHAR (255) NULL,
    PRIMARY KEY CLUSTERED ([item_id] ASC)
);


GO
PRINT N'Creating [dbo].[DbVersion]...';


GO
CREATE TABLE [dbo].[DbVersion] (
    [Id]            INT           IDENTITY (1, 1) NOT NULL,
    [Version]       NVARCHAR (20) NOT NULL,
    [DateInstalled] DATETIME      NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[OperationTypes]...';


GO
CREATE TABLE [dbo].[OperationTypes] (
    [subsystem_id]     INT            NOT NULL,
    [action_type_id]   INT            NOT NULL,
    [subsystem_name]   NVARCHAR (255) COLLATE Cyrillic_General_CI_AS NOT NULL,
    [action_type_name] NVARCHAR (255) COLLATE Cyrillic_General_CI_AS NOT NULL,
    CONSTRAINT [PK_OperationTypes] PRIMARY KEY CLUSTERED ([subsystem_id] ASC, [action_type_id] ASC)
);


GO
PRINT N'Creating [dbo].[Parameters]...';


GO
CREATE TABLE [dbo].[Parameters] (
    [parameter]    NVARCHAR (50)  COLLATE Cyrillic_General_CI_AS NOT NULL,
    [string_value] NVARCHAR (150) COLLATE Cyrillic_General_CI_AS NULL,
    [int_value]    BIGINT         NULL,
    [float_value]  FLOAT (53)     NULL,
    [description]  NVARCHAR (MAX) COLLATE Cyrillic_General_CI_AS NULL
);


GO
PRINT N'Creating [dbo].[Tasks]...';


GO
CREATE TABLE [dbo].[Tasks] (
    [entry_id]           BIGINT           IDENTITY (1, 1) NOT NULL,
    [batch_id]           UNIQUEIDENTIFIER NOT NULL,
    [subsystem_id]       INT              NOT NULL,
    [action_type_id]     INT              NOT NULL,
    [command]            NVARCHAR (4000)  NOT NULL,
    [date_added]         DATETIME         NOT NULL,
    [date_started]       DATETIME         NULL,
    [date_completed]     DATETIME         NULL,
    [duration_s]         INT              NULL,
    [database_id]        INT              NOT NULL,
    [table_id]           INT              NULL,
    [index_id]           INT              NULL,
    [partition_n]        INT              NULL,
    [maxdop]             INT              NULL,
    [user_scans]         BIGINT           NULL,
    [user_seeks]         BIGINT           NULL,
    [user_updates]       BIGINT           NULL,
    [rowcnt]             BIGINT           NULL,
    [size_mb]            DECIMAL (38, 3)  NULL,
    [ix_frag]            DECIMAL (10, 3)  NULL,
    [time_factor]        FLOAT (53)       NULL,
    [rowmod_factor]      FLOAT (53)       NULL,
    [checked_daysago]    INT              NULL,
    [result]             NVARCHAR (MAX)   NULL,
    [time_prognosis_s]   BIGINT           NULL,
    [exit_code]          INT              NULL,
    [worker_name]        NVARCHAR (255)   NULL,
    [execution_id]       UNIQUEIDENTIFIER NULL,
    [priority]           INT              NULL,
    [volume_mount_point] NVARCHAR (255)   NULL,
    CONSTRAINT [PK_TasksHistory] PRIMARY KEY CLUSTERED ([entry_id] ASC)
);


GO
PRINT N'Creating [dbo].[Tasks].[NC_IX_duration_plus_five]...';


GO
CREATE NONCLUSTERED INDEX [NC_IX_duration_plus_five]
    ON [dbo].[Tasks]([time_prognosis_s] ASC)
    INCLUDE([entry_id], [subsystem_id], [action_type_id], [database_id], [table_id], [index_id], [partition_n])
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[Tasks].[NC_db_tbl_ix_prt]...';


GO
CREATE NONCLUSTERED INDEX [NC_db_tbl_ix_prt]
    ON [dbo].[Tasks]([database_id] ASC, [table_id] ASC, [index_id] ASC, [partition_n] ASC, [date_completed] ASC, [subsystem_id] ASC, [action_type_id] ASC, [time_factor] ASC, [exit_code] ASC)
    INCLUDE([duration_s], [ix_frag]) WITH (FILLFACTOR = 50, PAD_INDEX = ON)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[Tasks].[NC_db_subs_dc]...';


GO
CREATE NONCLUSTERED INDEX [NC_db_subs_dc]
    ON [dbo].[Tasks]([database_id] ASC, [subsystem_id] ASC, [date_completed] ASC);


GO
PRINT N'Creating [dbo].[Workers]...';


GO
CREATE TABLE [dbo].[Workers] (
    [worker_name]            NVARCHAR (255) NOT NULL,
    [date_added]             DATETIME       NOT NULL,
    [owner]                  NVARCHAR (150) NOT NULL,
    [comment]                NVARCHAR (500) NOT NULL,
    [use_user_db]            BIT            NOT NULL,
    [use_system_db]          BIT            NOT NULL,
    [dbname_list]            NVARCHAR (500) NOT NULL,
    [except_list]            BIT            NOT NULL,
    [indexes]                BIT            NOT NULL,
    [frag_eval_time_limit_s] INT            NULL,
    [stats]                  BIT            NOT NULL,
    [stats_sample]           NVARCHAR (50)  NULL,
    [checkall]               BIT            NOT NULL,
    [checktable]             BIT            NOT NULL,
    [checkalloc]             BIT            NOT NULL,
    [checkcatalog]           BIT            NOT NULL,
    [online_only]            BIT            NOT NULL,
    [check_backup_state]     BIT            NOT NULL,
    [check_ag_state]         BIT            NOT NULL,
    [ag_max_queue]           BIGINT         NOT NULL,
    [afterparty]             BIT            NOT NULL,
    [add_stats_runtime]      BIT            NOT NULL,
    [totaltimemin]           BIGINT         NULL,
    [indextime]              BIGINT         NULL,
    [stattime]               BIGINT         NULL,
    [checktime]              BIGINT         NULL,
    [latched_spid]           INT            NULL,
    [stoplight]              BIT            NULL,
    CONSTRAINT [PK_Workers] PRIMARY KEY CLUSTERED ([worker_name] ASC) ON [PRIMARY]
) ON [PRIMARY];


GO
PRINT N'Creating [dbo].[WorkerSessions]...';


GO
CREATE TABLE [dbo].[WorkerSessions] (
    [record_date]   DATETIME       NOT NULL,
    [worker_name]   NVARCHAR (255) NOT NULL,
    [session_id]    INT            NOT NULL,
    [program_name]  NVARCHAR (150) NULL,
    [subsystem_id]  INT            NULL,
    [entry_id]      BIGINT         NULL,
    [is_afterparty] BIT            NULL,
    CONSTRAINT [AK_WorkerSession_worker_name] UNIQUE NONCLUSTERED ([worker_name] ASC)
) ON [PRIMARY];


GO
PRINT N'Creating [dbo].[FragmentationData]...';


GO
CREATE TABLE [dbo].[FragmentationData] (
    [entry_id]                     BIGINT           IDENTITY (1, 1) NOT NULL,
    [batch_id]                     UNIQUEIDENTIFIER NOT NULL,
    [collection_date]              DATETIME         NOT NULL,
    [database_id]                  SMALLINT         NOT NULL,
    [schema_id]                    INT              NOT NULL,
    [object_id]                    INT              NOT NULL,
    [object_name]                  NVARCHAR (517)   NOT NULL,
    [index_id]                     INT              NOT NULL,
    [index_name]                   [sysname]        NOT NULL,
    [allow_page_locks]             BIT              NOT NULL,
    [legacy_col_count]             INT              NOT NULL,
    [xml_col_count]                INT              NOT NULL,
    [user_scans]                   BIGINT           NOT NULL,
    [partition_count]              INT              NOT NULL,
    [partition_number]             INT              NOT NULL,
    [row_count]                    BIGINT           NOT NULL,
    [size_mb]                      DECIMAL (10, 3)  NOT NULL,
    [avg_fragmentation_in_percent] DECIMAL (10, 3)  NULL,
    [analysis_started]             DATETIME         NULL,
    [analysis_completed]           DATETIME         NULL,
    [analysis_spid]                INT              NULL,
    [analysis_duration_ms]         BIGINT           NULL,
    [analysis_status]              INT              NULL,
    [analysis_time_prognosis_ms]   BIGINT           NULL,
    [exit_code]                    INT              NULL,
    [exit_message]                 NVARCHAR (4000)  NULL,
    [analysis_batch_id]            UNIQUEIDENTIFIER NULL,
    [time_factor]                  FLOAT (53)       NULL,
    [volume_mount_point]           NVARCHAR (255)   NULL,
    CONSTRAINT [PK_FragmentationData] PRIMARY KEY CLUSTERED ([entry_id] ASC) ON [PRIMARY]
) ON [PRIMARY];


GO
PRINT N'Creating [dbo].[FragmentationData].[IX_FragData_Status_entry_databaseid]...';


GO
CREATE NONCLUSTERED INDEX [IX_FragData_Status_entry_databaseid]
    ON [dbo].[FragmentationData]([analysis_status] ASC, [entry_id] ASC, [database_id] ASC, [avg_fragmentation_in_percent] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[FragmentationData].[IX_FragData_dbid_objid_indexid_part_start_completed_code]...';


GO
CREATE NONCLUSTERED INDEX [IX_FragData_dbid_objid_indexid_part_start_completed_code]
    ON [dbo].[FragmentationData]([database_id] ASC, [object_id] ASC, [index_id] ASC, [partition_number] ASC, [analysis_started] ASC, [analysis_completed] ASC, [exit_code] ASC)
    ON [PRIMARY];


GO
PRINT N'Creating [dbo].[FragmentationData].[IX_FragData_dbid_frag_spid_userscans]...';


GO
CREATE NONCLUSTERED INDEX [IX_FragData_dbid_frag_spid_userscans]
    ON [dbo].[FragmentationData]([database_id] ASC, [avg_fragmentation_in_percent] ASC, [analysis_spid] ASC, [user_scans] ASC)
    INCLUDE([object_id], [index_id], [partition_number], [size_mb])
    ON [PRIMARY];


GO
PRINT N'Creating unnamed constraint on [dbo].[DBCCChecksLog]...';


GO
ALTER TABLE [dbo].[DBCCChecksLog]
    ADD DEFAULT (getdate()) FOR [log_date];


GO
PRINT N'Creating unnamed constraint on [dbo].[Blacklist]...';


GO
ALTER TABLE [dbo].[Blacklist]
    ADD DEFAULT getdate() FOR [date_added];


GO
PRINT N'Creating unnamed constraint on [dbo].[Blacklist]...';


GO
ALTER TABLE [dbo].[Blacklist]
    ADD DEFAULT 1 FOR [enabled];


GO
PRINT N'Creating [dbo].[DF_Workers_date_added]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD CONSTRAINT [DF_Workers_date_added] DEFAULT (getdate()) FOR [date_added];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 'John Doe' FOR [owner];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 'Owner did not add any comment' FOR [comment];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [use_user_db];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 0 FOR [use_system_db];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT '' FOR [dbname_list];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 0 FOR [except_list];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [indexes];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [stats];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 'FULLSCAN' FOR [stats_sample];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [checkall];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [checktable];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [checkalloc];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [checkcatalog];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [online_only];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [check_backup_state];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [check_ag_state];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 20000000 FOR [ag_max_queue];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [afterparty];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 1 FOR [add_stats_runtime];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 0 FOR [latched_spid];


GO
PRINT N'Creating unnamed constraint on [dbo].[Workers]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD DEFAULT 0 FOR [stoplight];


GO
PRINT N'Creating unnamed constraint on [dbo].[WorkerSessions]...';


GO
ALTER TABLE [dbo].[WorkerSessions]
    ADD DEFAULT getdate() FOR [record_date];


GO
PRINT N'Creating unnamed constraint on [dbo].[WorkerSessions]...';


GO
ALTER TABLE [dbo].[WorkerSessions]
    ADD DEFAULT 0 FOR [is_afterparty];


GO
PRINT N'Creating [dbo].[FK_Tasks_OperationTypes]...';


GO
ALTER TABLE [dbo].[Tasks]
    ADD CONSTRAINT [FK_Tasks_OperationTypes] FOREIGN KEY ([subsystem_id], [action_type_id]) REFERENCES [dbo].[OperationTypes] ([subsystem_id], [action_type_id]);


GO
PRINT N'Creating [dbo].[FK_WorkerSession_Workers]...';


GO
ALTER TABLE [dbo].[WorkerSessions]
    ADD CONSTRAINT [FK_WorkerSession_Workers] FOREIGN KEY ([worker_name]) REFERENCES [dbo].[Workers] ([worker_name]);


GO
PRINT N'Creating [dbo].[CK_Workers_Time]...';


GO
ALTER TABLE [dbo].[Workers]
    ADD CONSTRAINT [CK_Workers_Time] CHECK (ISNULL(indextime,0)+ISNULL(stattime,0)+ISNULL(checktime,0) <= 100);


GO
PRINT N'Creating [dbo].[Executions]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Arseny Birukov arsbir@microsoft.com

Это представление показывает агрегированную статистику по выполненным таскам
This view shows agregated statistics on executed tasks

*/


CREATE VIEW Executions
AS
SELECT 
	worker_name,
	[execution_id],
	ot.subsystem_name,
	ot.action_type_name,
	count(*) as total_task_count,
	count(CASE WHEN exit_code = 1 THEN 1 ELSE NULL END) as successful_task_count,
	count(CASE WHEN exit_code > 1 THEN 1 ELSE NULL END) as failed_task_count,
	count(CASE WHEN exit_code < 0 THEN 1 ELSE NULL END) as skipped_task_count,
	sum(DATEDIFF(ms,date_started, date_completed))/1000 as total_duration_s,
	sum(CASE WHEN exit_code > 1 THEN DATEDIFF(ms,date_started, date_completed) ELSE 0 END)/1000 as failed_duration_s,
	min(date_started) as first_task_started,
	max(date_completed) as last_task_completed,
	max(entry_id) as last_entry_id  --this column is needed for automated reports collection system
FROM 
	dbo.Tasks t
	INNER JOIN dbo.OperationTypes ot ON t.subsystem_id = ot.subsystem_id AND t.action_type_id = ot.action_type_id
WHERE
	[execution_id] is not null --Exclude not yet executed
GROUP BY
	[execution_id],
	worker_name,
	ot.subsystem_name,
	ot.action_type_name
--ORDER BY
--	worker_name,
--	execution_guid,
--	first_task_started
GO
PRINT N'Creating [dbo].[FragAnalysisStatus]...';


GO
CREATE VIEW [dbo].[FragAnalysisStatus]
	AS
	select 
       batch_id,
       MAX(collection_date) as MaxDateAdded,
       MIN(analysis_started) as FirstAnalysisStarted,
       CASE WHEN analysis_status = 0 then NULL ELSE  max(analysis_completed) END as RecentAnalysisCompleted, 
       ISNULL(DATEDIFF(SECOND,MIN(analysis_started),COALESCE(MAX(analysis_completed),getdate())),0) as Duration,
       CASE analysis_status       
             WHEN 0 THEN 'Scheduled' 
             WHEN 1 THEN 'Analized' 
             WHEN 2 THEN 'Completed'
             ELSE 'Error' END as [Status],
       exit_code,
       count(*) as [TasksCount],
       SUM(size_mb) as SizeMB,
       SUM(size_mb)*100.00/SUM(SUM(size_mb)) over (PARTITION BY batch_id) as [SizePercentTotal]
       ,COUNT(*)*100.00/SUM(count(*)) over(PARTITION BY batch_id) as [CountPercentTotal]
  
  FROM [dbo].[FragmentationData]
  GROUP BY batch_id,analysis_status,exit_code
GO
PRINT N'Creating [dbo].[GetTimeFactor]...';


GO

/*
-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.


Author: Oleg Trutnev otrutnev@microsoft.com

Russian:

Скалярная функция получения величины time factor, которая используется для предсказания времени выполнения заданий. 
Используется статистика ранее выполненных заданий. Для отсечки девиаций используется 2-сигма окрестность.
*/

CREATE FUNCTION [dbo].[GetTimeFactor] (
	@db INT
	,@execution bit --  1 - tasks execution or 0 - index fragmentation evaluation
	,@tableid INT
	,@indexid INT
	,@partitionnum INT
	,@subsystem_id INT = 1
	,@action_type_id INT =1
	,@days_past INT = 60
	,@normalize INT = 1
	)
RETURNS FLOAT
AS
BEGIN
	DECLARE 
		@RESULT FLOAT
		,@avg FLOAT
		,@dev FLOAT

IF @execution = 1
BEGIN
	
	SELECT 
		@avg = avg(time_factor)
		,@dev = stdev(time_factor)
	FROM [dbo].[Tasks] (NOLOCK)
	WHERE [database_id] = @db
		AND ((table_id is null and @tableid is null) or (table_id = @tableid))
		AND ((index_id is null and @indexid is null) or (index_id = @indexid))
		AND ((partition_n is null and @partitionnum is null) or (partition_n = partition_n))
		AND subsystem_id = @subsystem_id
		AND [action_type_id] = @action_type_id
		AND datediff(dd, date_completed, getdate()) < @days_past
		AND time_factor IS NOT NULL
		AND exit_code = 1
		and size_mb > 0
	
	IF @normalize = 1 AND @dev IS NOT NULL
	BEGIN
		SELECT @RESULT = AVG(time_factor)
		FROM [dbo].[Tasks] (NOLOCK)
		WHERE [database_id] = @db
			AND ((table_id is null and @tableid is null) or (table_id = @tableid))
			AND ((index_id is null and @indexid is null) or (index_id = @indexid))
			AND ((partition_n is null and @partitionnum is null) or (partition_n = partition_n))
			AND subsystem_id = @subsystem_id
			AND [action_type_id] = @action_type_id
			AND time_factor BETWEEN @avg - @dev
				AND @avg + @dev
			AND  date_completed > DATEADD(dd,-1*@days_past,getdate())
			AND time_factor IS NOT NULL
			AND exit_code = 1
			and size_mb > 0

		


	END
	ELSE
	BEGIN
		SET @RESULT = @avg
	END
	--If no data available then try to use history of other tasks
	IF @RESULT is NULL --try find data for another partition
			SELECT @RESULT = AVG(time_factor)
			FROM [dbo].[Tasks] (NOLOCK)
			WHERE [database_id] = @db
			AND ((table_id is null and @tableid is null) or (table_id = @tableid))
			AND ((index_id is null and @indexid is null) or (index_id = @indexid))
			--AND ((partition_n is null and @partitionnum is null) or (partition_n = partition_n))
			AND subsystem_id = @subsystem_id
			AND [action_type_id] = @action_type_id
			
			AND  date_completed > DATEADD(dd,-1*@days_past,getdate())
			AND time_factor IS NOT NULL
			AND exit_code = 1
			and size_mb > 0
			
			IF @RESULT is NULL --if still nothing try another index on same table
				SELECT @RESULT = AVG(time_factor)
			FROM [dbo].[Tasks] (NOLOCK)
			WHERE [database_id] = @db
			AND ((table_id is null and @tableid is null) or (table_id = @tableid))
			--AND ((index_id is null and @indexid is null) or (index_id = @indexid))
			--AND ((partition_n is null and @partitionnum is null) or (partition_n = partition_n))
			AND subsystem_id = @subsystem_id
			AND [action_type_id] = @action_type_id
			
			AND  date_completed > DATEADD(dd,-1*@days_past,getdate())
			AND time_factor IS NOT NULL
			AND exit_code = 1
			and size_mb > 0
					
					IF @RESULT is NULL --If still nothing try another table
						SELECT @RESULT = AVG(time_factor)
							FROM [dbo].[Tasks] (NOLOCK)
							WHERE [database_id] = @db
							--AND ((table_id is null and @tableid is null) or (table_id = @tableid))
							--AND ((index_id is null and @indexid is null) or (index_id = @indexid))
							--AND ((partition_n is null and @partitionnum is null) or (partition_n = partition_n))
							AND subsystem_id = @subsystem_id
							AND [action_type_id] = @action_type_id
							
							AND  date_completed > DATEADD(dd,-1*@days_past,getdate())
							AND time_factor IS NOT NULL
							AND exit_code = 1
							and size_mb > 0

							IF @RESULT is NULL --may be other database?
						SELECT @RESULT = AVG(time_factor)
							FROM [dbo].[Tasks] (NOLOCK)
							WHERE
							--[database_id] = @db
							--AND ((table_id is null and @tableid is null) or (table_id = @tableid))
							--AND ((index_id is null and @indexid is null) or (index_id = @indexid))
							--AND ((partition_n is null and @partitionnum is null) or (partition_n = partition_n))
							subsystem_id = @subsystem_id
							AND [action_type_id] = @action_type_id
							AND  date_completed > DATEADD(dd,-1*@days_past,getdate())
							AND time_factor IS NOT NULL
							AND exit_code = 1
							and size_mb > 0

					IF @RESULT is NULL --well, if nothing is available, then we'll use basic values for this kind of operations. cross your fingers...
						SET @RESULT = CASE @subsystem_id 
										WHEN  1 then 0.05 
										WHEN 2 THEN 0.05 
										WHEN 3 THEN CASE @action_type_id 
													WHEN 1 then 0.025
													when 2 then 0.05 
													when 3 then 0.05 
													end 
										end 	
END

ELSE --If we deal with fragmentation data and not the execution statistics
	BEGIN
	SELECT 
				@avg = avg(time_factor)
				,@dev = stdev(time_factor)
			FROM [dbo].[FragmentationData] (NOLOCK)
			WHERE [database_id] = @db
				AND (object_id = @tableid)
				AND (index_id = @indexid)
				AND (partition_number = @partitionnum)
				
				AND analysis_completed > DATEADD(dd,-1*@days_past,GETDATE())
				AND time_factor IS NOT NULL
				AND exit_code = 1
	
			IF @normalize = 1 AND @dev IS NOT NULL
			BEGIN
				SELECT @RESULT = AVG(time_factor)
				FROM [dbo].[FragmentationData] (NOLOCK)
				WHERE [database_id] = @db
					AND (object_id = @tableid)
				AND (index_id = @indexid)
				AND (partition_number = @partitionnum)
					AND time_factor BETWEEN @avg - @dev
						AND @avg + @dev
					AND analysis_completed > DATEADD(dd,-1*@days_past,GETDATE())
					AND time_factor IS NOT NULL
					AND exit_code = 1

					END
	ELSE
	BEGIN
		SET @RESULT = @avg
	END

	
	END
RETURN @RESULT
END
GO
PRINT N'Creating [dbo].[GetAGSyncState]...';


GO
CREATE FUNCTION dbo.GetAGSyncState
(
@dbint_id int
,@ag_max_queue bigint
)

RETURNS BIT
AS
BEGIN
DECLARE @result bit = 0
select top 1 @result = 1 from sys.dm_hadr_database_replica_states
where database_id = @dbint_id
and is_local = 0
and (synchronization_health <> 2
or log_send_queue_size > @ag_max_queue
or redo_queue_size > @ag_max_queue)
RETURN @result
END
GO
PRINT N'Creating [dbo].[GetDBBackupState]...';


GO
CREATE FUNCTION [dbo].[GetDBBackupState]
(
	@dbint_id int
)
RETURNS bit
AS
BEGIN
	DECLARE @result bit = 0
	select top 1 @result = 1 from sys.dm_exec_requests 
	where command like 'BACKUP DATABASE%' and database_id = @dbint_id
	RETURN @result
END
GO
PRINT N'Creating [dbo].[GetDbList]...';


GO
CREATE FUNCTION [dbo].[GetDbList]
(
	@use_system_db bit,
	@use_user_db bit,
	@dbname_list varchar(500),
	@except_list bit
)

RETURNS TABLE
AS
RETURN 	
SELECT database_id 
FROM sys.databases 
WHERE 
	is_read_only = 0 
	AND [state] = 0 
	AND ( 
		(@use_system_db=1 and name in ('master','msdb','VBMS')) 
		or 
		(@use_user_db=1 and name not in ('master','msdb','model','tempdb','VBMS')) 
	)
	AND (
		@dbname_list='' 
		or 
		(@except_list=0 and ','+@dbname_list+',' like '%,'+name+',%') 
		or 
		(@except_list=1 and ','+@dbname_list+',' not like '%,'+name+',%') 
	)
GO
PRINT N'Creating [dbo].[CreateWorkerAndJob]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Arseny Birukov arsbir@microsoft.com


Процедура создает строчку в таблице Workers и пару джобов, необходимых для работы 
The procedure creates row in Workers table and a couple of jobs to run VBMS
*/



CREATE PROCEDURE [dbo].[CreateWorkerAndJob]
	@database_name varchar(500)    ,      --Database to check.
	@fill_queue_time varchar(5)    ,      --db analysis start time
	@start_worker_time varchar(5)  ,      --maintenance window start time
	@total_time int                ,      --Duration in minutes
	@worker_name nvarchar(255)     = NULL     --Leave NULL to set same as db name
AS
---------------------------------------------------------------------------------------------------------

IF DB_ID(@database_name) is null
	RAISERROR('Database %s does not exist',16,1,@database_name)

IF @fill_queue_time NOT LIKE '[0-9][0-9]:[0-9][0-9]'
	RAISERROR('@fill_queue_time should be in HH:MM format',16,1)

IF @start_worker_time NOT LIKE '[0-9][0-9]:[0-9][0-9]'
	RAISERROR('@start_worker_time should be in HH:MM format',16,1)

SET @worker_name = ISNULL(@worker_name,@database_name)

DELETE FROM [dbo].[Workers] WHERE worker_name = @worker_name

INSERT INTO [dbo].[Workers]
           ([worker_name]
           ,[date_added]
           ,[owner]
           ,[comment]
           ,[use_user_db]
           ,[use_system_db]
           ,[dbname_list]
           ,[except_list]
           ,[indexes]
           ,[stats]
           ,[checkall]
           ,[checktable]
           ,[checkalloc]
           ,[checkcatalog]
           ,[online_only]
           ,[afterparty]
           ,[add_stats_runtime]
           ,[totaltimemin]
           ,[indextime]
           ,[stattime]
           ,[checktime])
     VALUES 
           (@worker_name                     --Worker name
           ,getdate()                        --Creation date 
           ,SUSER_SNAME()                    --Creator
           ,'No comments'                    --Comment
           ,1                                --Process user databases
           ,0                                --0=do not process system databases
           ,@database_name                   --database name
           ,0                                --except_list=0 means that we don't want to exclude dbname from check
           ,1                                --perform index defragmentation
           ,1                                --recalculate statistics
           ,1                                --checkall=1 perform all dbcc checks
           ,1                                --checktable no effect if checkall=1
           ,1                                --checkalloc no effect if checkall=1
           ,1                                --checkcatalog no effect if checkall=1
           ,0                                --0 = perform both online and offline checks
           ,1                                --perform afterparty processing
           ,1                                --add stats during run time
           ,@total_time                      --maintenace window in minutes
           ,NULL                             --% time for index rebulds. Default value in Preferences table
           ,NULL                             --% time for statistics
           ,NULL)                            --% time for alloc

PRINT 'Worker added'
------------------------------------------------------------------------------------------------------------------------
-- 1st job

DECLARE 
	@ReturnCode INT,
	@job_id BINARY(16),
	@job_name nvarchar(300),
	@job_command  nvarchar(1000),
	@owner_login varchar(100),
	@job_start_time int

/****** Object:  Job [VBMS_FillQueueAll_CRM]    Script Date: 30.10.2014 14:49:56 ******/
BEGIN TRANSACTION


SET @ReturnCode = 0

IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'Database Maintenance' AND category_class=1)
BEGIN
	EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'Database Maintenance'
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
END

SET @job_name = 'VBMS_FillQueueAll_'+@worker_name
SET @job_command = N'EXEC [dbo].[FillQueueAll] @dbname_list='''+@database_name+''''
SET @owner_login = SUSER_SNAME()
SET @job_start_time = DATEPART(HOUR,@fill_queue_time)*10000+DATEPART(MINUTE,@fill_queue_time)*100


IF (EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE name = @job_name))
BEGIN
	EXEC @ReturnCode = msdb.dbo.sp_delete_job @job_name = @job_name
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	PRINT 'Existing job deleted'
END

EXEC @ReturnCode =  msdb.dbo.sp_add_job 
		@job_name=@job_name,
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'No description available.', 
		@category_name=N'Database Maintenance', 
		@owner_login_name=@owner_login, 
		@job_id = @job_id OUTPUT

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

/****** Object:  Step [Fill Queue]    Script Date: 30.10.2014 14:49:56 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep 
		@job_id=@job_id, 
		@step_name=N'Fill Queue', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=@job_command, 
		@database_name=N'VBMS', 
		@flags=0

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

EXEC @ReturnCode = msdb.dbo.sp_update_job 
	@job_id = @job_id, 
	@start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule
		@job_id=@job_id, 
		@name=@job_name, 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=1, 
		@freq_subday_interval=0, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20141028, 
		@active_end_date=99991231, 
		@active_start_time=@job_start_time, 
		@active_end_time=235959

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

EXEC @ReturnCode = msdb.dbo.sp_add_jobserver 
	@job_id = @job_id, 
	@server_name = N'(local)'

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

COMMIT TRANSACTION
GOTO EndSave

QuitWithRollback:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave:


PRINT 'Job 1 created'
------------------------------------------------------------------------------------------------------------------------
-- 2nd job

BEGIN TRANSACTION

SET @ReturnCode = 0
SET @job_name = 'VBMS_StartWorker_'+@worker_name
SET @job_command = N'EXEC [dbo].[StartWorker] '''+@database_name+''''
SET @job_start_time = DATEPART(HOUR,@start_worker_time)*10000+DATEPART(MINUTE,@start_worker_time)*100
SET @ReturnCode = 0
SET @job_id = NULL

IF (EXISTS (SELECT * FROM msdb.dbo.sysjobs WHERE name = @job_name))
BEGIN
	EXEC @ReturnCode = msdb.dbo.sp_delete_job @job_name = @job_name
	IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
	PRINT 'Existing job deleted'
END

EXEC @ReturnCode =  msdb.dbo.sp_add_job 
		@job_name=@job_name, 
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'No description available.', 
		@category_name=N'Database Maintenance', 
		@owner_login_name=@owner_login, 
		@job_id = @job_id OUTPUT

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2

/****** Object:  Step [Start Worker]    Script Date: 30.10.2014 15:00:35 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep 
		@job_id=@job_id, 
		@step_name=N'Start Worker', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=@job_command, 
		@database_name=N'VBMS', 
		@flags=0

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2

EXEC @ReturnCode = msdb.dbo.sp_update_job 
	@job_id = @job_id, 
	@start_step_id = 1

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2

EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule 
		@job_id=@job_id, 
		@name=@job_name, 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=1, 
		@freq_subday_interval=0, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20141028, 
		@active_end_date=99991231, 
		@active_start_time=@job_start_time, 
		@active_end_time=235959

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2

EXEC @ReturnCode = msdb.dbo.sp_add_jobserver 
	@job_id = @job_id, 
	@server_name = N'(local)'

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback2

COMMIT TRANSACTION

GOTO EndSave2

QuitWithRollback2:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION

EndSave2:

PRINT 'Job 2 created'
GO
PRINT N'Creating [dbo].[CheckLogSpaceLeft]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Oleg Trutnev otrutnev@microsoft.com
		Arseny Birukov arsbir@microsoft.com

Процедура оценивает объем свободного места, доступный для журнала транзакций
ВАЖНО: при использовании маунт пойнтов процедура ведет себя некорректно.

The procedure estimates the free space available for the transaction log
IMPORTANT: the result is wrong when mount points are used.
*/



CREATE PROCEDURE [dbo].[CheckLogSpaceLeft] 
(
	@db int, 
	@limit_mb bigint
)
--DECLARE @db int = 6,@limit_mb int = 5000
AS
DECLARE @sql nvarchar(max)
IF EXISTS (select 1 from sys.objects where name like '#result' and type = 'U')
DROP TABLE #result

CREATE TABLE #result  (
	dbname nvarchar(255),
	[mb_free] int
)

--We need dynamic t-sql to use FILEPROPERY function.
IF (@@MicrosoftVersion/0x01000000)<11
	BEGIN
	SET @sql='
USE [' + cast(db_name(@db) AS NVARCHAR(50)) + '];
DECLARE @Drives TABLE
(
	[drive] nvarchar(255),
	[free] bigint
)

INSERT INTO @Drives 
EXEC(''xp_fixeddrives'')

INSERT #result
SELECT
	DB_NAME(ms.database_id) as database_name,
	SUM(size/128.0 - CAST(FILEPROPERTY(name, ''SPACEUSED'') AS INT)/128.0 + CASE WHEN ms.max_size = -1 THEN d.free ELSE (max_size -size)/128.0 END) AS FREESPACEMB 
FROM 
	sys.master_files ms
	JOIN @Drives d on SUBSTRING(ms.physical_name,1,1) collate SQL_Latin1_General_CP1_CI_AS = d.drive collate SQL_Latin1_General_CP1_CI_AS
WHERE 
	database_id = DB_ID()
	and type = 1
GROUP BY 
	database_id
HAVING 
	SUM(size/128.0 - CAST(FILEPROPERTY(name, ''SPACEUSED'') AS INT)/128.0 + CASE WHEN ms.max_size = -1 THEN d.free ELSE (max_size -size)/128.0 END) < '+CAST(@limit_mb as nvarchar(50))
 END
 ELSE
 BEGIN
 set @sql = '
 USE [' + cast(db_name(@db) AS NVARCHAR(50)) + '];
 
INSERT #result
SELECT
	DB_NAME(ms.database_id) as database_name,
	SUM(size/128.0 - CAST(FILEPROPERTY(name, ''SPACEUSED'') AS INT)/128.0 + CASE WHEN ms.max_size = -1 THEN (vs.available_bytes)/1024/1024 ELSE (max_size -size)/128.0 END) AS FREESPACEMB 
FROM 
	sys.master_files ms
	CROSS APPLY sys.dm_os_volume_stats(ms.database_id, ms.file_id) vs
WHERE 
	ms.database_id = DB_ID()
	and type = 1
GROUP BY 
	ms.database_id
HAVING 
	SUM(size/128.0 - CAST(FILEPROPERTY(name, ''SPACEUSED'') AS INT)/128.0 + CASE WHEN ms.max_size = -1 THEN (vs.available_bytes)/1024/1024 ELSE (max_size -size)/128.0 END) < '+CAST(@limit_mb as nvarchar(50))
 
 END

EXEC(@sql)

IF @@rowcount >0
	BEGIN
	DROP TABLE #result
	RETURN 0
	END
ELSE 
	BEGIN
	DROP TABLE #result
	RETURN 1
	END
GO
PRINT N'Creating [dbo].[KillWorkers]...';


GO
/*
-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Oleg Trutnev otrutnev@microsoft.com



Russian:
Процедура прерывания процессов обработки очереди заданий (Worker). 
Процедура может принимать в качестве входного параметра список имен профилей через запятую без пробелов.
Если Worker обнаружен в состоянии выполения заданий обслуживания индексов, то прерывания не происходит,
 выполняется ожидание завершения этого процесса.
Это сделано с целью избежания отката операции с индексом, который может потребовать даже больше времени.  
Эта проверка отменяется параметром @force.

English:
Procedure designed to kill one or several Workers (names supplied as a list without spaces). 
If worker is found performing index operations then
procedure waits, to avoid rollback. If @force = 1, then worker is killed immediately.


*/



CREATE PROCEDURE [dbo].[KillWorkers] (@worker_names nvarchar(500) = '', @except_list bit = 0, @force bit = 0)
AS

DECLARE @spid INT
DECLARE @sql NVARCHAR(500) = ''
DECLARE @subsystem_id INT
DECLARE @entry_id bigint
DECLARE @victim nvarchar(50)

DECLARE workers CURSOR FORWARD_ONLY
	FOR SELECT worker_name, session_id, subsystem_id, entry_id from dbo.[WorkerSessions] 
	WHERE 
 (
      @worker_names='' 
      or 
      (@except_list=0 and ','+@worker_names+',' like '%,'+worker_name+',%') 
      or 
      (@except_list=1 and ','+@worker_names+',' not like '%,'+worker_name+',%') 
)

WHILE EXISTS (
SELECT 1 FROM dbo.[WorkerSessions] 
	WHERE 
 (
      @worker_names='' 
      or 
      (@except_list=0 and ','+@worker_names+',' like '%,'+worker_name+',%') 
      or 
      (@except_list=1 and ','+@worker_names+',' not like '%,'+worker_name+',%') 
)

)
BEGIN

DELETE FROM dbo.[WorkerSessions]
WHERE not exists(
	select 1 from sys.dm_exec_sessions es 
		where es.session_id = dbo.[WorkerSessions].session_id 
		and es.program_name COLLATE DATABASE_DEFAULT = dbo.[WorkerSessions].program_name COLLATE DATABASE_DEFAULT)

	
OPEN workers

FETCH NEXT FROM workers
INTO @victim, @spid,@subsystem_id, @entry_id

WHILE @@FETCH_STATUS = 0 
BEGIN
IF (@subsystem_id <> 1 or @force = 1)
	BEGIN
	SET @sql = 'KILL ' + cast(@spid AS NVARCHAR(10)) + '
			UPDATE dbo.Tasks SET result = ''Killed'',exit_code = 0, date_completed = getdate() WHERE entry_id = '+cast(@entry_id as nvarchar(10))+' 
			UPDATE dbo.Workers SET stoplight = 0 where worker_name = ''' + CAST(@victim AS NVARCHAR(36)) + ''' and stoplight <> 0
			DELETE FROM dbo.WorkerSessions where worker_name = ''' + CAST(@victim AS NVARCHAR(36)) + ''''

			EXEC (@sql)
			PRINT 'Worker ''' + CAST(@victim AS NVARCHAR(36)) + ''' has been killed at step' + cast(@subsystem_id AS NVARCHAR(5)) + ' at ' + CAST(GETDATE() as NVARCHAR(30)) + '. R.I.P. Bro...'
	END
ELSE
BEGIN
UPDATE dbo.Workers 
SET stoplight = -1
WHERE worker_name = @victim
AND stoplight = 0
END
FETCH NEXT FROM workers
INTO @victim, @spid,@subsystem_id, @entry_id

END

CLOSE workers
WAITFOR DELAY '00:00:05'
END

DEALLOCATE workers
GO
PRINT N'Creating [dbo].[ExecuteDBCCCheck]...';


GO

CREATE PROCEDURE [dbo].[ExecuteDBCCCheck]
	@action_type_id int = 1,
	@db int = 1,
	@object_id nvarchar(50) = NULL,
	@exec_guid uniqueidentifier = NULL
AS

DECLARE 
	@SQL nvarchar(max), 
	@msg nvarchar(max)
	--@sql1 nvarchar(255) 
 
 IF @exec_guid is null
	SET @exec_guid = NEWID()

 IF OBJECT_ID('tempdb..#t') IS NOT NULL
	DROP TABLE #t


IF DB_NAME(@db) is null
	RAISERROR ('Wrong database specified',16,1)

IF @action_type_id = 3 AND OBJECT_NAME(@object_id, @db) is null
BEGIN
	DECLARE @dbname sysname = DB_NAME(@db)
	RAISERROR ('Table with object_id = %d does not exist in database %s', 16, 1, @object_id, @dbname)
END


CREATE TABLE #t 
(
	[ErrorNum] [smallint] NULL,
	[Level] [tinyint] NULL,
	[State] [tinyint] NULL,
	[MessageText] [varchar](500) NULL,
	[RepairLevel] [varchar](40) NULL,
	[Status] [tinyint] NULL,
	[Dbid] [smallint] NULL,
	[DbFragId] [int] NULL,
	[ObjectId] [int] NULL,
	[IndexId] [int] NULL,
	[PartitionId] [bigint] NULL,
	[AllocUnitId] [bigint] NULL,
	[RidDbId] [int] NULL,
	[RidPruId] [int] NULL,
	[File] [int] NULL,
	[Page] [int] NULL,
	[Slot] [int] NULL,
	[RefDbId] [int] NULL,
	[RefPruId] [int] NULL,
	[RefFile] [int] NULL,
	[RefPage] [int] NULL,
	[RefSlot] [int] NULL,
	[Allocation] [int] NULL
)

SET @SQL = 
	N'USE ' + QUOTENAME(db_name(@db)) + N'; ' +
	CASE 
		WHEN @action_type_id=3 
		THEN N'DECLARE @table_name nvarchar(255)	SELECT @table_name = QUOTENAME(SCHEMA_NAME(schema_id))+''.''+QUOTENAME(name) FROM sys.objects WHERE object_id = ' + @object_id + N'; '
		ELSE N''
	END +
	N'INSERT INTO #t ' +
	CASE @action_type_id	
		WHEN 1 THEN N'EXEC(''DBCC CHECKCATALOG(['+db_name(@db)+N']) WITH NO_INFOMSGS'')'
		WHEN 2 THEN N'EXEC(''DBCC CHECKALLOC(['+db_name(@db)+N']) WITH NO_INFOMSGS, ALL_ERRORMSGS, TABLERESULTS'')'
		WHEN 3 THEN N'EXEC(''DBCC CHECKTABLE("''+@table_name+''") WITH NO_INFOMSGS, ALL_ERRORMSGS, TABLERESULTS'')'
		ELSE N'RAISERROR (''Incorrect value for parameter @action_type! 1 - CHECKCATALOG, 2 - CHECKALLOC, 3 - CHECKTABLE'',16,1)'
	END

EXEC (@SQL)

IF @@ROWCOUNT > 0
BEGIN
	SET @msg = N'Consistency check found some errors! See dbo.DBCCChecksLog table for details! execution_guid:'+cast(@exec_guid as nvarchar(40))

	IF (select @@MicrosoftVersion/0x01000000)<10
	BEGIN
		INSERT dbo.DBCCChecksLog(
			[execution_guid] , 
			log_date,
			error_num ,
			[level] ,
			[State] ,
			[message_text],
			[repair_level] ,
			[status] ,
			[database_id],
			[object_id] ,
			[index_id],
			[partition_id],
			[alloc_unit_id],
			[file],
			[page],
			[slot],
			[ref_file] ,
			[ref_page],
			[ref_slot] ,
			[allocation] 
		)
		SELECT			
			@exec_guid,
			getdate(),
			[ErrorNum] ,
			[Level] ,
			[State] ,
			[MessageText],
			[RepairLevel] ,
			[Status] ,
			[DbId],
			[ObjectId] ,
			[IndexId],
			[PartitionId],
			[AllocUnitId],
			[File],
			[Page],
			[Slot],
			[RefFile] ,
			[RefPage],
			[RefSlot] ,
			[Allocation]
		FROM #t
	END
	ELSE
	BEGIN
		INSERT dbo.DBCCChecksLog(
			[execution_guid] , 
			[log_date],
			[error_num],
			[level],
			[State],
			[message_text],
			[repair_level],
			[status],
			[database_id],
			[db_frag_id],
			[object_id],
			[index_id],
			[partition_id],
			[alloc_unit_id],
			[rid_db_id],
			[rid_pru_id],
			[file] ,
			[page] ,
			[slot] ,
			[ref_db_id],
			[ref_pru_id],
			[ref_file],
			[ref_page],
			[ref_slot],
			[allocation])
		SELECT @exec_guid,
			getdate(),
			[ErrorNum],
			[Level],
			[State],
			[MessageText],
			[RepairLevel],
			[Status],
			[Dbid],
			[DbFragId],
			[ObjectId],
			[IndexId],
			[PartitionId],
			[AllocUnitId],
			[RidDbId],
			[RidPruId],
			[File] ,
			[Page] ,
			[Slot] ,
			[RefDbId],
			[RefPruId],
			[RefFile],
			[RefPage],
			[RefSlot],
			[Allocation]
		FROM #t
	END
	RAISERROR (@msg,16,1)
END
GO
PRINT N'Creating [dbo].[AddBlacklistItem]...';


GO
CREATE PROCEDURE [dbo].[AddBlacklistItem]
	@entryid bigint = NULL,
	@database_id INT = NULL , 
    @table_id INT = NULL, 
    @index_id INT = NULL, 
    @partition_n INT = NULL, 
    @subsystem_id INT = NULL, 
    @action_type_id INT = NULL,
	@worker_name nvarchar(255) NULL
AS

IF @entryid is not null 
BEGIN 

	IF @database_id is not null or @table_id is not null or @index_id is not null or @partition_n is not null or @subsystem_id is not null or @action_type_id is not null
	BEGIN
		RAISERROR('Parameter @entryid is incompatible with other parameters!',16,1)
		RETURN
	END

	SELECT 
		@database_id=[database_id],
		@table_id = table_id,
		@index_id = index_id,
		@partition_n = partition_n,
		@subsystem_id = CASE WHEN @subsystem_id is null THEN subsystem_id ELSE @subsystem_id END,
		@action_type_id = CASE WHEN @action_type_id is null THEN action_type_id ELSE @action_type_id END
	FROM dbo.Tasks
	WHERE entry_id = @entryid

	IF @subsystem_id <> 1 
		SET @partition_n = NULL
		
END
ELSE
BEGIN
	IF @database_id is null
	BEGIN
		RAISERROR('database_id not defined!',16,1)
		RETURN
	END

	IF @subsystem_id is null and @database_id is null
	BEGIN
		RAISERROR('subsystem_id not defined while DB Id is also not defined.',16,1)
		RETURN
	END

	IF @table_id is null and @subsystem_id <> 3 and @action_type_id not in (1,2)
	BEGIN
		RAISERROR('table_id not defined! P.s. You can not blacklist the whole DB this way.',16,1)
		RETURN
	END
END	
	INSERT INTO dbo.Blacklist 
	(
		[database_id], 
		[table_id], 
		[index_id], 
		[partition_n], 
		[subsystem_id], 
		[action_type_id],
		[enabled],
		[worker_name]
	)
	VALUES
	( 
		@database_id,
		@table_id,
		@index_id,
		@partition_n,
		@subsystem_id, 
		@action_type_id,
		1
		,@worker_name
	)
GO
PRINT N'Creating [dbo].[FillQueueCheckAlloc]...';


GO

/*
-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Oleg Trutnev otrutnev@microsoft.com

Russian version:

Процедура формирования заданий проверки целостности БД с точки зрения аллокации.
Задание представляет собой выражение DBCC CHECKALLOC('<имя БД>').
Отбираются БД не проверявшиеся более чем количество дней, заданное параметром CheckAllocIntervalDays в таблице Parameters.
Задания упорядочиваются по давности последней проверки или размеру БД.

Englsh version:

Procedure creates a tasks of integrity checks of DB extents allocation.
Tasks are statements like DBCC CHECKALLOC('<DB name>').
Databases are being scheduled for check if they have not been checked for more than X days,
where X is a value of CheckAllocIntervalDays parameter in dbo.Parameters table.
Tasks are sorted by date of last check and/or DB size Mb.
  


*/
CREATE PROCEDURE [dbo].[FillQueueCheckAlloc] @db INT, @batch UNIQUEIDENTIFIER
AS

DECLARE	@SQL NVARCHAR(MAX)


DECLARE @check_interval int
SELECT @check_interval = int_value
FROM dbo.Parameters where parameter = 'CheckAllocIntervalDays'

DECLARE @worker_name nvarchar(255)
SELECT @worker_name = worker_name
FROM dbo.WorkerSessions
WHERE session_id = @@SPID

DELETE
FROM dbo.Tasks
WHERE subsystem_id = 3 --Подсистема проверки целостности / subsystem_id 3 is an integrity check
	AND action_type_id = 2 -- CHECKALLOC
	AND date_completed IS NULL
	AND [database_id] = @db

DECLARE @last_check datetime

SELECT 
	@last_check = MAX(date_completed)
FROM dbo.Tasks
WHERE database_id = @db
	AND subsystem_id = 3
	AND action_type_id = 2
	AND exit_code = 1


IF 
	DATEDIFF(dd,ISNULL(@last_check,0),getdate()) > @check_interval
	AND NOT EXISTS (SELECT 1 
		FROM dbo.Blacklist bl
		WHERE 
			bl.database_id = @db
			AND (bl.subsystem_id = 3 or bl.subsystem_id is null)
			AND (bl.action_type_id = 2 or action_type_id is null)
			AND (bl.worker_name = @worker_name or worker_name is null)
			AND bl.enabled = 1)

INSERT INTO dbo.Tasks (
	[batch_id]
	,[subsystem_id]
	,[action_type_id]
	,[command]
	,[date_added]
	,[database_id]
	,[size_mb]
	,[checked_daysago]
)
SELECT
	@batch
	,3
	,2 
	,'USE [VBMS]; EXEC [dbo].[ExecuteDBCCCheck] @action_type_id = 2, @db = '+cast(@db as nvarchar(3))+'--DBCC CHECKALLOC(['+db_name(@db)+']) WITH NO_INFOMSGS'
	,getdate()
	,@db
	,sum(CAST(ps.used_page_count * 8 / 1024.00 AS DECIMAL(10, 3)))
	,DATEDIFF(dd,@last_check,getdate())
from 
	sys.dm_db_partition_stats ps
GO
PRINT N'Creating [dbo].[FillQueueCheckCatalog]...';


GO
/*
-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Oleg Trutnev otrutnev@microsoft.com


Russian version:

Процедура формирования заданий проверки целостности системного каталога БД.
Задание представляет собой выражение DBCC CHECKCATALOG('<имя БД>').
Отбираются БД не проверявшиеся более чем количество дней, заданное параметром CheckCatalogIntervalDays в таблице Parameters.
Задания упорядочиваются по давности последней проверки и размеру БД.

Englsh version:

Procedure creates a tasks of integrity checks of system tables.
Tasks are statements like DBCC CHECKTABLE('<DB name>').
Databases are being scheduled for check if they have not been checked for more than X days,
where X is a value of CheckCatalogIntervalDays parameter in dbo.Parameters table.
Tasks are sorted by date of last check and DB size Mb.

*/
CREATE PROCEDURE [dbo].[FillQueueCheckCatalog] @db INT, @batch UNIQUEIDENTIFIER
AS

--Считываем параметры / Loading parameters
DECLARE @check_interval int
SELECT @check_interval = int_value
FROM dbo.Parameters where parameter = 'CheckCatalogIntervalDays'

DECLARE @worker_name nvarchar(255)
SELECT @worker_name = worker_name
FROM dbo.WorkerSessions
WHERE session_id = @@SPID

--Удаляем устаревшие невыполненные задания / Old tasks cleanup
DELETE
FROM dbo.Tasks
WHERE subsystem_id = 3     --Подсистема проверки целостности / subsystem_id 3 is an integrity check
	AND action_type_id = 1 -- CHECKCATALOG
	AND date_completed IS NULL
	AND [database_id] = @db

DECLARE @last_check datetime

SELECT 
	@last_check = MAX(date_completed)
FROM dbo.Tasks
WHERE database_id = @db
	AND subsystem_id = 3
	AND action_type_id = 1
	AND exit_code = 1


IF 
	DATEDIFF(dd,ISNULL(@last_check,0),getdate()) > @check_interval
	AND NOT EXISTS (SELECT 1 
		FROM dbo.Blacklist bl
		WHERE 
			bl.database_id = @db
			AND (bl.subsystem_id = 3 or bl.subsystem_id is null)
			AND (bl.action_type_id = 1 or action_type_id is null)
			AND (bl.worker_name = @worker_name or worker_name is null)
			AND bl.enabled = 1)

INSERT INTO dbo.Tasks (
	[batch_id]
	,[subsystem_id]
	,[action_type_id]
	,[command]
	,[date_added]
	,[database_id]
	,[size_mb]
	,[checked_daysago]
)
SELECT
	@batch
	,3
	,1 
	,'USE [VBMS]; EXEC [dbo].[ExecuteDBCCCheck] @action_type_id = 1, @db = '+cast(@db as nvarchar(3))+'--DBCC CHECKCATALOG(['+db_name(@db)+']) WITH NO_INFOMSGS'
	,getdate()
	,@db
	,5.0 --system catalog is usually 2-10 Mb for all DBs. Size does not really matter.
	,DATEDIFF(dd,@last_check,getdate())
GO
PRINT N'Creating [dbo].[FillQueueCheckTable]...';


GO
/*
-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Oleg Trutnev otrutnev@microsoft.com


Russian version:

Процедура формирования заданий проверки целостности отдельных таблиц.
Задание представляет собой выражение DBCC CHECKTABLE('<имя таблицы>').
Отбираются таблицы не проверявшиеся более чем количество дней, заданное параметром CheckTableIntervalDays в таблице Parameters.
Таблицы упорядочиваются по давности последней проверки и размеру таблицы.

Englsh version:

Procedure creates a tasks of integrity checks for perticular tables.
Tasks are statements like DBCC CHECKTABLE('<Table name>').
Tables are being scheduled for check if they have not been checked for more than X days,
where X is a value of CheckTableIntervalDays parameter in dbo.Parameters table.
Tasks are sorted by date of last check and table size Mb.

*/
CREATE PROCEDURE [dbo].[FillQueueCheckTable] 
	@db INT, 
	@batch UNIQUEIDENTIFIER, 
	@table_max_size_mb bigint = 1000000 --exclude bigger tables. By default no more than 1 Pb
AS

DECLARE	@SQL NVARCHAR(MAX)

DECLARE @check_interval int

SELECT @check_interval = int_value
FROM dbo.Parameters where parameter = 'CheckTableIntervalDays'


DECLARE @worker_name nvarchar(255)
SELECT @worker_name = worker_name
FROM dbo.WorkerSessions
WHERE session_id = @@SPID

IF @table_max_size_mb = 0
	SET @table_max_size_mb = 1000000

DELETE
FROM dbo.Tasks
WHERE subsystem_id = 3 --Тип действия Проверка целостности таблиц / subsystem_id 3 is an integrity check
	AND action_type_id = 3
	AND date_completed IS NULL
	AND [database_id] = @db


DECLARE @tables TABLE
(
	database_id int,
	schema_id int,
	object_id int,
	object_name nvarchar(4000),
	row_count bigint,
	size_mb decimal(10, 3)
)

SET @SQL = 
'USE '+QUOTENAME(DB_NAME(@db))+
'SELECT 
	DB_ID() as database_id, 
	t.schema_id, 
	t.object_id, 
	QUOTENAME(SCHEMA_NAME(t.schema_id))+''.''+QUOTENAME(OBJECT_NAME(t.object_id)) as object_name,
	sum(p.rows) as row_count,
	sum(CAST(ps.used_page_count * 8 / 1024.00 AS decimal(10, 3))) as size_mb
	
FROM 
	sys.tables t
	INNER JOIN sys.indexes i on t.object_id = i.object_id and i.index_id < 2 --Heap or clustered index
	INNER JOIN sys.partitions p ON p.object_id = t.object_id AND p.index_id = i.index_id
	LEFT JOIN sys.dm_db_partition_stats ps on ps.object_id = t.object_id AND ps.index_id = i.index_id AND ps.partition_number = p.partition_number
WHERE rows > 0
GROUP BY 
	t.schema_id, 
	t.object_id'
	
INSERT INTO @tables
EXEC (@SQL)


INSERT dbo.Tasks (
	[batch_id]
	,[subsystem_id]
	,[action_type_id]
	,[command]
	,[date_added]
	,[database_id]
	,[table_id]
	,[rowcnt]
	,[size_mb]
	,[checked_daysago]
)
SELECT
	@batch
	,3
	,3 
	,N'USE [VBMS]; EXEC [dbo].[ExecuteDBCCCheck] @action_type_id = 3, @db = '+cast(@db as nvarchar(4))+', @object_id = '+cast(nt.object_id as nvarchar(20)) +'; --DBCC CHECKTABLE('+nt.object_name+') WITH NO_INFOMSGS'
	,getdate()
	,@db
	,nt.object_id
	,nt.row_count
	,nt.size_mb
	,DATEDIFF(dd,pt.date_completed,getdate())
FROM
	@tables nt 
	LEFT OUTER JOIN
	( 
		SELECT 
			ROW_NUMBER() OVER (PARTITION BY table_id order by date_completed DESC) AS rn,
			table_id,
			date_completed
		FROM  
			dbo.Tasks
		WHERE 
			subsystem_id = 3
			AND action_type_id = 3
			AND database_id = @db
			AND exit_code = 1
	) pt ON pt.table_id = nt.object_id
WHERE
	ISNULL(nt.size_mb,0) < @table_max_size_mb
	AND (pt.rn = 1 OR pt.rn is null) --last row or nothing
	AND (DATEDIFF(dd,ISNULL(pt.date_completed,0),getdate()) > @check_interval OR pt.date_completed is null)
	AND NOT EXISTS
		(
			SELECT 1 
			FROM dbo.Blacklist bl
			WHERE 
				bl.database_id = @db 
				and (bl.table_id = nt.object_id or bl.table_id is null)
				and (bl.subsystem_id = 3 or bl.subsystem_id is null)
				and (bl.action_type_id = 3 or action_type_id is null)
				AND (bl.worker_name = @worker_name or worker_name is null)
				and bl.enabled = 1
		)
GO
PRINT N'Creating [dbo].[FillQueueIndex]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: 
Oleg Trutnev otrutnev@microsoft.com
Arseny Birukov arsbir@microsoft.com


Russian:

Процедура формирования заданий обслуживания индексов на основе их состояния. 
Задания - выражения для обслуживания отдельных индексов - добавляются в таблицу dbo.Tasks
Применяется оценка процента фрагментации и возможности перестройки индекса онлайн.
Для приоритезации заданий используется частота обращений к индексу (только user_scan), фрагментация и размер индекса.  

English:

Stored procedure creates tasks for index maintenance based on their state and operational stats.
Tasks are T-SQL statements of index REBUILD/REORGANIZE, that are inserted in dbo.Tasks table.
Index is evaluated by frag percent, user scans counter and size. 
First goes the most used (user scans) index with higher fragmentation and the larger size.   

 
*/

CREATE PROCEDURE [dbo].[FillQueueIndex] 
	 @db INT
	,@batch UNIQUEIDENTIFIER
	,@maxdop INT = NULL
	,@sortintempdb BIT = NULL
AS



DECLARE
	@reorg_threshold decimal(10,3),
	@frag_threshold bigint,
	@locktimeout bigint,
	@online_allowed bit,
	@SQL nvarchar(max),
	@index_minsize bigint
	
DECLARE @worker_name nvarchar(255)
SELECT @worker_name = worker_name
FROM dbo.WorkerSessions
WHERE session_id = @@SPID

--Удаляем устаревшие невыполненные задания / Old tasks cleanup
DELETE
FROM dbo.Tasks
WHERE subsystem_id = 1
	AND date_completed IS NULL
	AND [database_id] = @db

--Считываем параметры / Loading parameters
SELECT @reorg_threshold = int_value
FROM dbo.Parameters
WHERE parameter = 'IndexReorgThresholdPercent'

SELECT @locktimeout = int_value
FROM dbo.Parameters
WHERE parameter = 'LockTimeoutMs'

SELECT @frag_threshold = int_value
FROM dbo.Parameters
WHERE parameter = 'IndexFragLowerThreshold'

SELECT @index_minsize = int_value
FROM dbo.Parameters
WHERE parameter = 'IndexMinimumSizeMB'


IF (CAST(SERVERPROPERTY('Edition') as NVARCHAR(50)) LIKE N'%Enterprise%'
  OR CAST(SERVERPROPERTY('Edition') as NVARCHAR(50)) LIKE N'%Datecenter%'
  OR CAST(SERVERPROPERTY('Edition') as NVARCHAR(50)) LIKE N'%Developer%')
	SELECT @online_allowed = int_value
	FROM dbo.Parameters
	WHERE parameter = 'IndexOnlineRebuild'
ELSE 
	SET @online_allowed = 0

--Get list of all partitions and some stats on them
--This statement should be executed in different database context, so we have to use dynamic T-SQL
--The statement itself is static, it's relatively easy to unquote it
SET @SQL = 
'USE '+QUOTENAME(DB_NAME(@db))+';

IF OBJECT_ID(''tempdb..#frag_data'') is not null
	DROP TABLE #frag_data
SELECT 
	DB_ID() as database_id, 
	t.schema_id, 
	t.object_id, 
	QUOTENAME(SCHEMA_NAME(t.schema_id))+''.''+QUOTENAME(OBJECT_NAME(t.object_id)) as object_name,
	--per index data:
	i.index_id,
	i.name as index_name,
	i.allow_page_locks,
	--c.legacy_col_count,
	--c.xml_col_count,
	ISNULL(ius.user_scans,0) as user_scans,
	count(*) OVER (PARTITION BY t.object_id, i.index_id) as partition_count,
	--per partition data:
	p.partition_number,
	p.rows as row_count,
	CAST(ps.used_page_count * 8 / 1024.00 AS DECIMAL(10,3)) as size_mb,
	CAST(ips.avg_fragmentation_in_percent as DECIMAL(10,3)) as avg_fragmentation_in_percent
INTO #frag_data
FROM 
	sys.tables t
	INNER JOIN sys.indexes i on t.object_id = i.object_id 
	INNER JOIN sys.partitions p ON p.object_id = t.object_id AND p.index_id = i.index_id
	LEFT OUTER JOIN sys.dm_db_partition_stats ps on ps.object_id = t.object_id AND ps.index_id = i.index_id AND ps.partition_number = p.partition_number
	LEFT OUTER JOIN sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, ''LIMITED'') ips ON ips.object_id = i.object_id AND ips.index_id = i.index_id AND ips.partition_number = p.partition_number AND alloc_unit_type_desc = ''IN_ROW_DATA''
	LEFT OUTER JOIN sys.dm_db_index_usage_stats ius ON ius.database_id = DB_ID() AND ius.index_id = i.index_id AND ius.object_id = i.object_id
	--LEFT OUTER JOIN
	--(  --number of legacy and xml columns is needed to decide if online rebuild is possible
	--   --If the index is clustered, consider all columns
	--	SELECT 
	--		c.object_id, 
	--		i.index_id,
	--		ISNULL(SUM(CASE WHEN TYPE_NAME(c.system_type_id) IN (''image'',''text'',''ntext'') THEN 1 ELSE 0 END),0) as legacy_col_count,
	--		ISNULL(SUM(CASE WHEN TYPE_NAME(c.system_type_id) = ''xml''  THEN 1 ELSE 0 END),0) as xml_col_count
	--	FROM 
	--		sys.columns c
	--		INNER JOIN sys.indexes i ON i.object_id = c.object_id
	--		LEFT OUTER JOIN	sys.index_columns ic ON ic.object_id = c.object_id	AND ic.column_id = c.column_id AND ic.index_id = i.index_id
	--	WHERE
	--		(i.index_id = 1               -- index is clustered (count all columns)
	--		OR ic.index_id is not null)   -- OR nonclustered    (count only index columns)
	--		GROUP BY 
	--		c.object_id, i.index_id	
	--) c ON c.index_id = i.index_id AND c.object_id = i.object_id
WHERE
	i.index_id > 0 -- we cant rebuild heap
	and ps.used_page_count > ' + CAST(@index_minsize /8 * 1024 as NVARCHAR(10))+ '
	and ips.avg_fragmentation_in_percent >' + CAST(@frag_threshold as NVARCHAR(10))+'

SELECT  
i.database_id,
i.schema_id,
i.object_id,
i.object_name,
i.index_id,
i.index_name,
i.allow_page_locks,
c.legacy_col_count,
c.xml_col_count,
i.user_scans,
i.partition_count,
i.partition_number,
i.row_count,
i.size_mb,
i.avg_fragmentation_in_percent

FROM #frag_data i
LEFT OUTER JOIN
	(  --number of legacy and xml columns is needed to decide if online rebuild is possible
	   --If the index is clustered, consider all columns
		SELECT 
			c.object_id, 
			i.index_id,
			ISNULL(SUM(CASE WHEN TYPE_NAME(c.system_type_id) IN (''image'',''text'',''ntext'') THEN 1 ELSE 0 END),0) as legacy_col_count,
			ISNULL(SUM(CASE WHEN TYPE_NAME(c.system_type_id) = ''xml''  THEN 1 ELSE 0 END),0) as xml_col_count
		FROM 
			sys.columns c
			INNER JOIN sys.indexes i ON i.object_id = c.object_id
			LEFT OUTER JOIN	sys.index_columns ic ON ic.object_id = c.object_id	AND ic.column_id = c.column_id AND ic.index_id = i.index_id
		WHERE
			(i.index_id = 1               -- index is clustered (count all columns)
			OR ic.index_id is not null)   -- OR nonclustered    (count only index columns)
			GROUP BY 
			c.object_id, i.index_id	
	) c ON c.index_id = i.index_id AND c.object_id = i.object_id

DROP TABLE #frag_data



'
IF OBJECT_ID('tempdb..#partitions') is not null
	DROP TABLE #partitions

CREATE TABLE #partitions
(
	database_id int, 
	schema_id int,  
	object_id int, 
	object_name nvarchar(4000),
	index_id int,
	index_name nvarchar(4000),
	allow_page_locks bit,
	legacy_col_count int,
	xml_col_count int,
	user_scans bigint,
	partition_count int,
	partition_number int,
	row_count bigint,
	size_mb decimal(10,3),
	avg_fragmentation_in_percent decimal(10,3)
)

INSERT INTO #partitions
EXEC (@SQL)



INSERT dbo.Tasks (
	batch_id
	,subsystem_id
	,action_type_id
	,command
	,date_added
	,[database_id]
	,table_id
	,index_id
	,partition_n
	,[maxdop]
	,ix_frag
	,user_seeks
	,user_scans
	,user_updates
	,rowcnt
	,size_mb
	,[priority]
)
SELECT
	@batch,
	1,  --index maintenance
	t.action_type_id,
	t.command,
	getdate(),
	@db,
	t.object_id,
	t.index_id,
	t.partition_number,
	t.maxdop,
	t.avg_fragmentation_in_percent,
	NULL, --removed seeks - useless
	t.user_scans,
	NULL, --removed updates
	t.row_count,
	t.size_mb,
	CASE WHEN ISNULL(pt.exit_code,1) <> 1 THEN 2 ELSE 1 END --Если предыдущий таск завершился с ошибкой понижаем этму приоритет
FROM
	(
		SELECT
			CASE 
				WHEN t.action = N'REBUILD' AND t.online LIKE N'OFF%' THEN 1
				WHEN t.action = N'REBUILD' AND t.online is null THEN 1
				WHEN t.action = N'REBUILD' AND t.online LIKE N'ON%' THEN 2
				WHEN t.action = N'REORGANIZE' THEN 3
			END as action_type_id,
			--Конструирую выражение / Assembling statement
			N'USE ' + QUOTENAME(DB_NAME(@db)) + N'; ' +
			CASE WHEN @locktimeout<60000 or (@@MicrosoftVersion/0x01000000)<12 THEN N'SET LOCK_TIMEOUT ' + t.lock_timeout + N'; ' ELSE '' END +
			N'ALTER INDEX [' + t.index_name + N'] ON '+ t.object_name + N' ' + t.action + N' ' + t.partition_spec +
			CASE WHEN t.action = N'REBUILD' THEN N'WITH ('+COALESCE('ONLINE='+ t.online,'') +N'SORT_IN_TEMPDB='+ t.sort_in_tempdb + N'MAXDOP='+ t.maxdop + N')' ELSE N'' END + N';' --rebuild options
			as command,
			*
		FROM
			(	--Подготавливаю опции / prepare options for the statement
				SELECT 
					--REORG or REBUILD:
					CASE WHEN avg_fragmentation_in_percent > @reorg_threshold THEN N'REBUILD' ELSE N'REORGANIZE' END as [action],
					--If we have multiple partitions, specify the partition number
					CASE WHEN partition_count > 1 THEN N' PARTITION = ' + CAST(partition_number as nvarchar(10)) ELSE N'' END + N' ' as partition_spec,
					--Sort in tempdb determined by global option
					CASE WHEN @sortintempdb = 1 THEN N'ON, ' ELSE N'OFF, ' END [sort_in_tempdb],
					--If possible, perform online rebuild
					CASE 
						WHEN @online_allowed = 0 THEN N'OFF, /*disabled*/ '  --online is disabled in settings
						WHEN legacy_col_count > 0 THEN N'OFF, /*legacy*/ ' --legacy column types can't be rebuilt online
						WHEN xml_col_count > 0 AND (@@MicrosoftVersion/0x01000000)<11 THEN N'OFF, /*xml*/ ' --xml columns can't be rebuild online prior to 2012
						--WHEN partition_count = 1 THEN NULL --one partition can't be rebuild online and even OFF is incorrect
						WHEN partition_count > 1 AND (@@MicrosoftVersion/0x01000000)<12 THEN NULL --prior to SQL 2014 partitions could not be rebuilt online and even OFF is incorrect
						ELSE --We can use online rebuild
							CASE 
							--Starting from 2014 rebuild can wait at low priority:
								WHEN (@@MicrosoftVersion/0x01000000)>=12 and @locktimeout > 60000 /*more than a minute */ THEN N'ON (WAIT_AT_LOW_PRIORITY ( MAX_DURATION = '+cast(@locktimeout/60000 as nvarchar(20))+' , ABORT_AFTER_WAIT = SELF ) ),' 
								
								ELSE N'ON, ' --Simply online
								
								
							END

					END as [online],
					--Lock timeout from global settings
					CAST(@locktimeout as nvarchar(10)) as [lock_timeout],
					--Set maxdop if page locks are not prohibited. See  http://support.microsoft.com/kb/2292737 
					CASE 
						WHEN [allow_page_locks] = 1 OR (@@MicrosoftVersion/0x01000000)>=11  THEN  CAST(ISNULL(@maxdop,1) AS nvarchar(10))
						--WHEN @allow_pl = 0 AND (@@MicrosoftVersion/0x01000000)<11 THEN N'1' 
						ELSE N'1'
					END as [maxdop],
					*
				FROM 
					#partitions p
			) t
	) t
	OUTER APPLY --находим такой же предыдущий таск / Find similar prevous task 
	(
		SELECT TOP 1 pt.exit_code 
		FROM
			dbo.Tasks pt
		WHERE
			pt.subsystem_id = 1 
			AND pt.action_type_id = t.action_type_id
			AND pt.database_id = t.database_id
			AND pt.table_id = t.object_id
			AND pt.index_id = t.index_id
			AND pt.partition_n = t.partition_number
			AND pt.date_completed is not null
		ORDER BY
			pt.date_completed DESC
	) pt
WHERE
	--Фрагментация выше порога / Fragmentation above threshold
	t.avg_fragmentation_in_percent > @frag_threshold
	AND size_mb > @index_minsize
	AND	NOT EXISTS	(
		SELECT 1 
		FROM dbo.Blacklist bl
		WHERE 
			bl.[database_id] = @db 
			AND (bl.table_id = t.object_id or bl.table_id is null)
			AND (bl.index_id = t.index_id or bl.index_id is null) 
			AND (bl.subsystem_id = 1 or bl.subsystem_id is null)
			AND (bl.action_type_id = t.action_type_id or bl.action_type_id is null)
			AND (bl.partition_n = t.partition_number or bl.partition_n is null)
			AND (bl.worker_name = @worker_name or worker_name is null)
			AND bl.enabled = 1
	)
ORDER BY 
	t.user_scans DESC,
	t.avg_fragmentation_in_percent DESC,
	t.size_mb DESC
GO
PRINT N'Creating [dbo].[FillQueueStat]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.
Author: Oleg Trutnev otrutnev@microsoft.com


Version 2.0.2.5

Russian:
Процедура добавления заданий пересчёта статистики в таблицу dbo.Tasks
При оценке актуальности статистики используется динамический порог,
работающий аналогично флагу трассировки 2371. Автор формулы Juergen Thomas.
Для приоретизации используется процент превышения порога перерасчёта статистики (поле rowmod_factor)

English:

Stored procedure creates tasks for statistics update in table dbo.Tasks.
Each task is a T-SQL Statement UPDATE STATISTICS(<Table name>) WITH FULLSCAN.
Dynamic threshold formula like in traceflag 2371 is used.
Formula is created by Juergen Thomas.
Tasks are sorted by rowmod_factor that is computed like a percent of threshold deviation.
Greater is worse.

*/
CREATE PROCEDURE [dbo].[FillQueueStat] @db INT ,@batch UNIQUEIDENTIFIER = null, @sample nvarchar(50) = 'FULLSCAN'
AS
DECLARE	@SQL NVARCHAR(MAX)
	,@tableid INT
	,@indexid INT
	,@partitionnum INT
	,@subsystem_id INT
	,@actiontype INT
	,@entryid BIGINT

IF @batch is null
SET @batch = newid()

IF @sample not like N'SAMPLE % ROWS' AND @sample not like N'FULLSCAN' AND @sample not like N'RESAMPLE' AND @sample not like N'SAMPLE % PERCENT'
BEGIN SET @sample = N'RESAMPLE' --@sample parameter control. 
PRINT N'Warning! Incorrect sample selected! Using RESAMPLE!'
END



DELETE --delete old tasks, because they are now useless.
FROM dbo.Tasks
WHERE subsystem_id = 2 --Подсистема обслуживания статистики / Statistics management subsystem_id tasks
	AND date_completed IS NULL
	AND [database_id] = @db
	AND [worker_name] IS NULL

SET @SQL = '
DECLARE @worker_name nvarchar(255)
SELECT @worker_name = worker_name
FROM VBMS.dbo.WorkerSessions
WHERE session_id = @@SPID

USE [' + db_name(@db) + '];
 INSERT VBMS.dbo.Tasks (
 batch_id
 ,subsystem_id
 ,action_type_id
 ,command
 ,date_added
 ,database_id
 ,table_id
 ,index_id
 ,size_mb
 ,rowcnt
 ,rowmod_factor)
 (
SELECT DISTINCT
''' + CAST(@batch AS NVARCHAR(50)) + '''
	,2
	,1
	,''USE [' + DB_NAME(@db) + 
	']
	UPDATE STATISTICS ['' + SCHEMA_NAME(so.schema_id) + ''].['' + OBJECT_NAME(so.object_id) +''] [''+ISNULL(s.name, '''') + ''] WITH '+@sample+''' AS command
	,getdate()
	,db_id()
	,so.object_id
	,s.stats_id
	,SUM(CAST(ps.used_page_count * 8 / 1024.00 AS DECIMAL(10, 3))) AS size_mb
	,ssi2.rows
	,CASE 
		WHEN ssi2.rows < 25000
			THEN (((ssi.rowmodctr + 0.0001) / (ssi2.rows + 0.000001)) * 100.00 - (ssi2.rows * 0.2 + 500) / (ssi2.rows +0.000001) * 100)
		ELSE (((ssi.rowmodctr + 0.0001) / (ssi2.rows + 0.000001)) * 100.00 - sqrt((ssi2.rows) * 1000.00) / (ssi2.rows + 0.000001) * 100.00)
		END as rowmod_factor
FROM sys.stats  s (NOLOCK)
join sys.dm_db_partition_stats ps (NOLOCK)  on s.object_id = ps.object_id and ps.index_id < 2
join sys.sysindexes ssi (NOLOCK)  on s.object_id = ssi.id and ssi.indid = s.stats_id
join sys.objects so (NOLOCK)  on so.object_id = s.object_id
AND so.type IN (
		N''U''
		,N''V''
		)
join sys.sysindexes ssi2 on s.object_id = ssi2.id and ssi2.indid < 2
join sys.indexes si  on s.object_id = si.object_id and si.index_id = s.stats_id and si.type in (1,2)
WHERE so.is_ms_shipped = 0
	AND
	(ssi2.rows > 500)
		AND ssi.rowmodctr > (
			CASE 
				WHEN (ssi2.rows < 25000)
					THEN (sqrt((ssi2.rows) * 1000))
				WHEN ((ssi2.rows) > 25000)
					THEN ((ssi2.rows) * 0.2 + 500)
				END
			)
--Blacklisting
AND not exists
(SELECT 1 
FROM VBMS.dbo.Blacklist bl
WHERE 
 (bl.database_id = db_id() 
 and (bl.table_id = so.object_id or bl.table_id is null))
 and (bl.index_id = s.stats_id or bl.index_id is null) 
and (bl.subsystem_id = 2 or bl.subsystem_id is null)
AND (bl.worker_name = @worker_name or worker_name is null)
and bl.enabled = 1
)
--Blacklisting
GROUP BY so.schema_id
	,so.object_id
	,s.stats_id
	,s.name
	,ssi.rowmodctr 
	,ssi2.rows
	
	
)'

EXEC(@SQL)


DECLARE TASKS CURSOR
FOR SELECT entry_id, table_id,index_id,partition_n,subsystem_id, action_type_id
FROM dbo.Tasks WHERE time_prognosis_s is null
and database_id = @db
and batch_id = @batch


OPEN TASKS

FETCH NEXT FROM TASKS
INTO @entryid,@tableid,@indexid,@partitionnum,@subsystem_id,@actiontype

WHILE @@FETCH_STATUS = 0 
BEGIN 

UPDATE dbo.Tasks
SET time_prognosis_s = ISNULL(dbo.GetTimeFactor(@db,1,@tableid,@indexid,@partitionnum,@subsystem_id, @actiontype,60,1),0) * size_mb
WHERE entry_id = @entryid
FETCH NEXT FROM TASKS
INTO @entryid,@tableid,@indexid,@partitionnum,@subsystem_id,@actiontype


END

CLOSE TASKS
DEALLOCATE TASKS
GO
PRINT N'Creating [dbo].[CloneWorkers]...';


GO
/*
Procedure to add more workers by cloning existing one.

--dbo.CloneWorkers 'AW',2 --add two workers to AW
--dbo.CloneWorkers @worker_name= 'AW',@workers_num = 6, @already_have =2

*/

CREATE PROCEDURE dbo.CloneWorkers (
@worker_name nvarchar(255) --worker to use as a template,
,@workers_num int --number of workers to add
,@already_have int = 1 --numbers of workers, that we already got. Used to avoid PK violation.,
,@name_postfix nvarchar(20) = '_' --postfix to use between the worker name and it's number. Ex: worker_1, worker_2
)
AS
SET NOCOUNT ON
DECLARE @i int 
 
SET @i = @already_have+1

WHILE @i <= @already_have+@workers_num
	BEGIN
	BEGIN TRY
	INSERT INTO [dbo].[Workers]
           ([worker_name]
           ,[date_added]
           ,[owner]
           ,[comment]
           ,[use_user_db]
           ,[use_system_db]
           ,[dbname_list]
           ,[except_list]
           ,[indexes]
           ,[stats]
           ,[stats_sample]
           ,[checkall]
           ,[checktable]
           ,[checkalloc]
           ,[checkcatalog]
           ,[online_only]
           ,[afterparty]
           ,[add_stats_runtime]
           ,[totaltimemin]
           ,[indextime]
           ,[stattime]
           ,[checktime]
           )
     SELECT 
			@worker_name+@name_postfix+CAST(@i as nvarchar(5))
	       ,[date_added]
           ,[owner]
           ,[comment]
           ,[use_user_db]
           ,[use_system_db]
           ,[dbname_list]
           ,[except_list]
           ,[indexes]
           ,[stats]
           ,[stats_sample]
           ,[checkall]
           ,[checktable]
           ,[checkalloc]
           ,[checkcatalog]
           ,[online_only]
           ,[afterparty]
           ,0 --in parallel mode it is not recommended to use add_stats_runtime in several threads or duplicate tasks can be generated.
           ,[totaltimemin]
           ,[indextime]
           ,[stattime]
           ,[checktime]
	FROM dbo.Workers
	WHERE worker_name = @worker_name
	END TRY
	BEGIN CATCH
		THROW 51000,'Error during worker creation. Please check if it is already registered. If you need to add more workers please use starting_num parameter to set the starting position in naming to avoid duplicates.',1
	END CATCH
	SET @i = @i+1
	END
PRINT 'Workers have been created! Please note, that add_stats_runtime has been set to 0 for the added workers! Only one worker in the pack can have it set to 1 to avoid duplicate stats tasks creation during the execution.'
GO
PRINT N'Creating [dbo].[FillQueueIndex_async]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: 
Oleg Trutnev otrutnev@microsoft.com
Arseny Birukov arsbir@microsoft.com


Russian:

Процедура формирования заданий обслуживания индексов на основе их состояния. 
Задания - выражения для обслуживания отдельных индексов - добавляются в таблицу dbo.Tasks
Применяется оценка процента фрагментации и возможности перестройки индекса онлайн.
Для приоритезации заданий используется частота обращений к индексу (только user_scan), фрагментация и размер индекса.  

English:

Stored procedure creates tasks for index maintenance based on their state and operational stats.
Tasks are T-SQL statements of index REBUILD/REORGANIZE, that are inserted in dbo.Tasks table.
Index is evaluated by frag percent, user scans counter and size. 
First goes the most used (user scans) index with higher fragmentation and the larger size.   

 
*/

CREATE PROCEDURE [dbo].[FillQueueIndex_async] 
	 @db INT
	,@batch UNIQUEIDENTIFIER
	,@maxdop INT = NULL
	,@sortintempdb BIT = NULL
	,@entry_id bigint = NULL
AS



DECLARE
	@reorg_threshold decimal(10,3),
	@frag_threshold bigint,
	@locktimeout bigint,
	@online_allowed bit,
	@SQL nvarchar(max),
	@index_minsize bigint
	
DECLARE @worker_name nvarchar(255)
SELECT @worker_name = worker_name
FROM dbo.WorkerSessions
WHERE session_id = @@SPID


--Считываем параметры / Loading parameters
SELECT @reorg_threshold = int_value
FROM dbo.Parameters
WHERE parameter = 'IndexReorgThresholdPercent'

SELECT @locktimeout = int_value
FROM dbo.Parameters
WHERE parameter = 'LockTimeoutMs'

SELECT @frag_threshold = int_value
FROM dbo.Parameters
WHERE parameter = 'IndexFragLowerThreshold'


SELECT @index_minsize = int_value
FROM dbo.Parameters
WHERE parameter = 'IndexMinimumSizeMB'

IF @maxdop is null
SELECT @maxdop = int_value
		FROM dbo.Parameters
		WHERE parameter = 'MaxDop'

IF @sortintempdb IS NULL
		SELECT @sortintempdb= int_value
		FROM dbo.Parameters
		WHERE parameter = 'SortInTempdb'


IF (CAST(SERVERPROPERTY('Edition') as NVARCHAR(50)) LIKE N'%Enterprise%'
  OR CAST(SERVERPROPERTY('Edition') as NVARCHAR(50)) LIKE N'%Datacenter%'
  OR CAST(SERVERPROPERTY('Edition') as NVARCHAR(50)) LIKE N'%Developer%')
	SELECT @online_allowed = int_value
	FROM dbo.Parameters
	WHERE parameter = 'IndexOnlineRebuild'
ELSE 
	SET @online_allowed = 0
	

IF OBJECT_ID('tempdb..#partitions') is not null
	DROP TABLE #partitions

CREATE TABLE #partitions
(
	database_id int, 
	schema_id int,  
	object_id int, 
	object_name nvarchar(4000),
	index_id int,
	index_name nvarchar(4000),
	volume_mount_point nvarchar(255),
	allow_page_locks bit,
	legacy_col_count int,
	xml_col_count int,
	user_scans bigint,
	partition_count int,
	partition_number int,
	row_count bigint,
	size_mb decimal(10,3),
	avg_fragmentation_in_percent decimal(10,3)
)

INSERT INTO #partitions
SELECT 
database_id,
schema_id,
object_id,
object_name,
index_id,
index_name,
volume_mount_point,
allow_page_locks,
legacy_col_count,
xml_col_count,
user_scans,
partition_count,
partition_number,
row_count,
size_mb,
avg_fragmentation_in_percent
FROM
[dbo].[FragmentationData] with (FORCESEEK)
WHERE
(entry_id = @entry_id
OR
(@entry_id is NULL and 
database_id = @db
and analysis_status = 1))
AND avg_fragmentation_in_percent > @frag_threshold



INSERT dbo.Tasks (
	batch_id
	,subsystem_id
	,action_type_id
	,command
	,date_added
	,[database_id]
	,table_id
	,index_id
	,partition_n
	,[maxdop]
	,ix_frag
	,user_seeks
	,user_scans
	,user_updates
	,rowcnt
	,size_mb
	,[priority]
	,volume_mount_point
)
SELECT
	@batch,
	1,  --index maintenance
	t.action_type_id,
	t.command,
	getdate(),
	@db,
	t.object_id,
	t.index_id,
	t.partition_number,
	t.maxdop,
	t.avg_fragmentation_in_percent,
	NULL, --removed seeks - useless
	t.user_scans,
	NULL, --removed updates
	t.row_count,
	t.size_mb,
	CASE WHEN ISNULL(pt.exit_code,1) <> 1 THEN 2 ELSE 1 END --Если предыдущий таск завершился с ошибкой понижаем этму приоритет
	,t.volume_mount_point
FROM
	(
		SELECT
			CASE 
				WHEN t.action = N'REBUILD' AND t.online LIKE N'OFF%' THEN 1
				WHEN t.action = N'REBUILD' AND t.online is null THEN 1
				WHEN t.action = N'REBUILD' AND t.online LIKE N'ON%' THEN 2
				WHEN t.action = N'REORGANIZE' THEN 3
			END as action_type_id,
			--Конструирую выражение / Assembling statement
			N'USE ' + QUOTENAME(DB_NAME(@db)) + N'; ' +
			CASE WHEN @locktimeout<60000 or (@@MicrosoftVersion/0x01000000)<12 THEN N'SET LOCK_TIMEOUT ' + t.lock_timeout + N'; ' ELSE '' END +
			N'ALTER INDEX [' + t.index_name + N'] ON '+ t.object_name + N' ' + t.action + N' ' + t.partition_spec +
			CASE WHEN t.action = N'REBUILD' THEN N'WITH ('+COALESCE('ONLINE='+ t.online,'') +N'SORT_IN_TEMPDB='+ t.sort_in_tempdb + N'MAXDOP='+ t.maxdop + N')' ELSE N'' END + N';' --rebuild options
			as command,
			*
		FROM
			(	--Подготавливаю опции / prepare options for the statement
				SELECT 
					--REORG or REBUILD:
					CASE WHEN avg_fragmentation_in_percent > @reorg_threshold THEN N'REBUILD' ELSE N'REORGANIZE' END as [action],
					--If we have multiple partitions, specify the partition number
					CASE WHEN partition_count > 1 THEN N' PARTITION = ' + CAST(partition_number as nvarchar(10)) ELSE N'' END + N' ' as partition_spec,
					--Sort in tempdb determined by global option
					CASE WHEN @sortintempdb = 1 THEN N'ON, ' ELSE N'OFF, ' END [sort_in_tempdb],
					--If possible, perform online rebuild
					CASE 
						WHEN @online_allowed = 0 THEN N'OFF, /*disabled*/ '  --online is disabled in settings
						WHEN legacy_col_count > 0 THEN N'OFF, /*legacy*/ ' --legacy column types can't be rebuilt online
						WHEN xml_col_count > 0 AND (@@MicrosoftVersion/0x01000000)<11 THEN N'OFF, /*xml*/ ' --xml columns can't be rebuild online prior to 2012
						--WHEN partition_count = 1 THEN NULL --one partition can't be rebuild online and even OFF is incorrect
						WHEN partition_count > 1 AND (@@MicrosoftVersion/0x01000000)<12 THEN NULL --prior to SQL 2014 partitions could not be rebuilt online and even OFF is incorrect
						ELSE --We can use online rebuild
							CASE 
							--Starting from 2014 rebuild can wait at low priority:
								WHEN (@@MicrosoftVersion/0x01000000)>=12 and @locktimeout >= 60000 /*more than a minute */ THEN N'ON (WAIT_AT_LOW_PRIORITY ( MAX_DURATION = '+cast(@locktimeout/60000 as nvarchar(20))+' , ABORT_AFTER_WAIT = SELF ) ),' 
								
								ELSE N'ON, ' --Simply online
								
								
							END

					END as [online],
					--Lock timeout from global settings
					CAST(@locktimeout as nvarchar(10)) as [lock_timeout],
					--Set maxdop if page locks are not prohibited. See  http://support.microsoft.com/kb/2292737 
					CASE 
						WHEN [allow_page_locks] = 1 OR (@@MicrosoftVersion/0x01000000)>=11  THEN  CAST(ISNULL(@maxdop,1) AS nvarchar(10))
						--WHEN @allow_pl = 0 AND (@@MicrosoftVersion/0x01000000)<11 THEN N'1' 
						ELSE N'1'
					END as [maxdop],
					*
				FROM 
					#partitions p
			) t
	) t
	OUTER APPLY --находим такой же предыдущий таск / Find similar prevous task 
	(
		SELECT TOP 1 pt.exit_code 
		FROM
			dbo.Tasks pt
		WHERE
			pt.subsystem_id = 1 
			AND pt.action_type_id = t.action_type_id
			AND pt.database_id = t.database_id
			AND pt.table_id = t.object_id
			AND pt.index_id = t.index_id
			AND pt.partition_n = t.partition_number
			AND pt.date_completed is not null
		ORDER BY
			pt.date_completed DESC
	) pt
WHERE
	--Фрагментация выше порога / Fragmentation above threshold
	NOT EXISTS	(
		SELECT 1 
		FROM dbo.Blacklist bl
		WHERE 
			bl.[database_id] = @db 
			AND (bl.table_id = t.object_id or bl.table_id is null)
			AND (bl.index_id = t.index_id or bl.index_id is null) 
			AND (bl.subsystem_id = 1 or bl.subsystem_id is null)
			AND (bl.action_type_id = t.action_type_id or bl.action_type_id is null)
			AND (bl.partition_n = t.partition_number or bl.partition_n is null)
			AND (bl.worker_name = @worker_name or worker_name is null)
			AND bl.enabled = 1
	)
ORDER BY 
	t.user_scans DESC,
	t.avg_fragmentation_in_percent DESC,
	t.size_mb DESC
GO
PRINT N'Creating [dbo].[CollectIndexFragData]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: 
Oleg Trutnev otrutnev@microsoft.com



Russian:



English:


 
*/

CREATE PROCEDURE [dbo].[CollectIndexFragData] 
	@db int
	,@time_limit_s int = 3600
	,@batch_id uniqueidentifier= NULL
	,@maxdop int=  NULL
	,@sortintempdb bit =NULL
AS
SET NOCOUNT ON
DECLARE
	
	@SQL nvarchar(max),
	@locktimeout bigint
	IF @batch_id is null
		SET @batch_id = NEWID()
	
SELECT @locktimeout = int_value
FROM dbo.Parameters
WHERE parameter = 'LockTimeoutMs'	

--Удаляем устаревшие невыполненные задания / Old tasks cleanup
--DELETE
--FROM dbo.FragmentationData
--WHERE analysis_spid = @@SPID
--	and analysis_started is not null
--	AND analysis_complete is NULL
--	AND [database_id] = @db



SET @SQL = 
'USE '+QUOTENAME(DB_NAME(@db))+';

DECLARE @t1 datetime
,@timefactor float
,@exit_code int
,@Error_message nvarchar(max)

SET @t1 = DATEADD(s,'+CAST(@time_limit_s as nvarchar(255))+',GETDATE())


----Fill Fragmentation Data

SET LOCK_TIMEOUT '+CAST(@locktimeout as nvarchar(10))+';

SET NOCOUNT ON
	DECLARE @entry_id bigint, 
			@db int, 
			@table_id int,
			@index_id int, 
			@partition_id int, 
			@frag int, 
			@size_mb int,
			@batch_id uniqueidentifier
	SET @batch_id = '''+CAST(@batch_id as nvarchar(50))+'''

	DECLARE PARTS CURSOR 
	FOR SELECT entry_id, DB_ID(),object_id, index_id, partition_number, size_mb
	FROM VBMS.dbo.FragmentationData WITH (NOLOCK) where avg_fragmentation_in_percent IS NULL and database_id = DB_ID() and analysis_spid is null
	ORDER BY user_scans desc


	OPEN PARTS

	FETCH NEXT FROM PARTS
	INTO @entry_id, @db, @table_id, @index_id,@partition_id, @size_mb

	WHILE @@FETCH_STATUS=0
	BEGIN
	SET @timefactor = ISNULL(VBMS.dbo.GetTimeFactor(@db,0,@table_id,@index_id,@partition_id,1, 1,60,1),0)
	--PRINT @entry_id
	--PRINT DATEDIFF(s,@t1,(DATEADD(s,(@size_mb * @timefactor/1000),getdate())))
	--PRINT DATEADD(s,(@size_mb * @timefactor/1000),getdate())
	IF exists (select 1 FROM 
				sys.indexes i 
	INNER JOIN sys.partitions p ON p.object_id = i.object_id AND p.index_id = i.index_id
	where i.object_id = @table_id 
		AND i.index_id = @index_id
		AND p.partition_number = @partition_id)
	IF (SELECT analysis_spid FROM VBMS.dbo.FragmentationData WHERE entry_id = @entry_id ) IS NULL
		BEGIN
		IF (DATEADD(s,(@size_mb * @timefactor/1000),getdate())<@t1)
		BEGIN
			UPDATE VBMS.dbo.FragmentationData WITH (ROWLOCK)
			SET analysis_started = GETDATE(), analysis_spid = @@SPID, analysis_batch_id = @batch_id
			,analysis_time_prognosis_ms = @size_mb * @timefactor
			where entry_id = @entry_id

			SET @exit_code = 1
			SET @error_message = ''Ok''
			BEGIN TRY				 	
			SELECT @frag =  avg_fragmentation_in_percent from sys.dm_db_index_physical_stats(@db,@table_id,@index_id,@partition_id,''LIMITED'') WHERE alloc_unit_type_desc = ''IN_ROW_DATA''
			END TRY
			BEGIN CATCH

						SET @exit_code = ERROR_NUMBER()
						SET @error_message = N''Error code: '' + CAST(ERROR_NUMBER() AS NVARCHAR(10)) + N''. Error message:'' + ERROR_MESSAGE()
			END CATCH
			
			UPDATE VBMS.dbo.FragmentationData
			SET avg_fragmentation_in_percent= @frag
				,analysis_completed = getdate()
				,analysis_status = 1
				--,analysis_time_prognosis_ms = @size_mb * @timefactor
				,analysis_duration_ms = DATEDIFF(ms,analysis_started,getdate())
				,time_factor = CASE WHEN @frag is not null THEN (DATEDIFF(ms, analysis_started, GETDATE())/ (size_mb + 1.0)) ELSE NULL END
				,exit_code = @exit_code
				,exit_message = @error_message
			WHERE entry_id = @entry_id and analysis_spid = @@SPID and avg_fragmentation_in_percent is null
			IF @exit_code = 1
				BEGIN 
				exec VBMS.dbo.FillQueueIndex_async @db = @db,@batch = @batch_id, @maxdop = '+ISNULL(CAST(@maxdop as nvarchar(50)),'NULL')+', @sortintempdb = '+ISNULL(CAST(@sortintempdb as nvarchar(50)),'NULL')+', @entry_id = @entry_id
				
			
				UPDATE VBMS.dbo.FragmentationData
				SET analysis_status = 2
				WHERE entry_id = @entry_id 
				END
			ELSE
				BEGIN
				UPDATE VBMS.dbo.FragmentationData
					SET analysis_status = 3
					WHERE entry_id = @entry_id 
				END
			END
		ELSE 
			BEGIN
			--Print @entry_id
			--Print ''Skipped''
			UPDATE VBMS.dbo.FragmentationData
			SET analysis_completed = getdate()
			,analysis_duration_ms = DATEDIFF(ms,analysis_started,getdate())
			,analysis_status = -1
			,time_factor = 0
			,exit_code = -1
			,exit_message = ''Skipped. Not enough time left''
			WHERE entry_id = @entry_id and analysis_spid is null and avg_fragmentation_in_percent is null
			END
		END

		
		FETCH NEXT FROM PARTS
		INTO @entry_id, @db, @table_id, @index_id,@partition_id, @size_mb
		END

	CLOSE PARTS
	DEALLOCATE PARTS


'

EXEC (@SQL)
GO
PRINT N'Creating [dbo].[CollectIndexData]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: 
Oleg Trutnev otrutnev@microsoft.com



Russian:



English:
  

 
*/

CREATE PROCEDURE [dbo].[CollectIndexData] 
	 @db INT
	,@batch UNIQUEIDENTIFIER = NULL
	
AS
SET NOCOUNT ON
DECLARE
	@SQL nvarchar(max),
	@index_minsize bigint,
	@locktimeout bigint

	IF @batch is null
		SET @batch = NEWID()

--Удаляем устаревшие невыполненные задания / Old tasks cleanup
DELETE FROM dbo.FragmentationData
	WHERE database_id = @db
	AND analysis_started is null
	
	

--Считываем параметры / Loading parameters

SELECT @index_minsize = int_value
FROM dbo.Parameters
WHERE parameter = 'IndexMinimumSizeMB'

SELECT @locktimeout = int_value
FROM dbo.Parameters
WHERE parameter = 'LockTimeoutMs'



--Get list of all partitions and some stats on them
--This statement should be executed in different database context, so we have to use dynamic T-SQL
--The statement itself is static, it's relatively easy to unquote it
SET @SQL = 
'USE '+QUOTENAME(DB_NAME(@db))+';

DECLARE @worker_name nvarchar(255)
SELECT @worker_name = worker_name
FROM VBMS.dbo.WorkerSessions
WHERE session_id = @@SPID

SET LOCK_TIMEOUT '+CAST(@locktimeout as nvarchar(10))+';

INSERT INTO VBMS.[dbo].[FragmentationData]
           ([batch_id]
           ,[collection_date]
           ,[database_id]
           ,[schema_id]
           ,[object_id]
           ,[object_name]
           ,[index_id]
           ,[index_name]
           ,[allow_page_locks]
           ,[legacy_col_count]
           ,[xml_col_count]
           ,[user_scans]
           ,[partition_count]
           ,[partition_number]
           ,[row_count]
           ,[size_mb]
           ,[avg_fragmentation_in_percent]
		   ,[analysis_status]
		   ,[volume_mount_point])
     
SELECT '''+CAST(@batch as nvarchar(50))+''',
GETDATE() as collection_date,
	DB_ID() as database_id, 
	t.schema_id, 
	t.object_id, 
	QUOTENAME(SCHEMA_NAME(t.schema_id))+''.''+QUOTENAME(OBJECT_NAME(t.object_id)) as object_name,
	--per index data:
	i.index_id,
	i.name as index_name,
	i.allow_page_locks,
	c.legacy_col_count,
	c.xml_col_count,
	ISNULL(ius.user_scans,0) as user_scans,
	count(*) OVER (PARTITION BY t.object_id, i.index_id) as partition_count,
	--per partition data:
	p.partition_number,
	p.rows as row_count,
	CAST(ps.used_page_count * 8 / 1024.00 AS DECIMAL(10,3)) as size_mb,
	NULL as avg_fragmentation_in_percent,
	0 as analysis_status,
	vs.volume_mount_point
	
FROM 
	sys.tables t
	INNER JOIN sys.indexes i on t.object_id = i.object_id 
	INNER JOIN sys.partitions p ON p.object_id = t.object_id AND p.index_id = i.index_id
	INNER JOIN sys.allocation_units au on p.partition_id = au.container_id and au.type =1
	INNER JOIN sys.data_spaces ds on au.data_space_id = ds.data_space_id
	INNER JOIN sys.database_files dbf on dbf.data_space_id = ds.data_space_id
	CROSS APPLY sys.dm_os_volume_stats(DB_ID(),dbf.file_id) vs
	LEFT OUTER JOIN sys.dm_db_partition_stats ps on ps.object_id = t.object_id AND ps.index_id = i.index_id AND ps.partition_number = p.partition_number
	LEFT OUTER JOIN sys.dm_db_index_usage_stats ius ON ius.database_id = DB_ID() AND ius.index_id = i.index_id AND ius.object_id = i.object_id
	LEFT OUTER JOIN
	(  --number of legacy and xml columns is needed to decide if online rebuild is possible
	   --If the index is clustered, consider all columns
		SELECT 
			c.object_id, 
			i.index_id,
			ISNULL(SUM(CASE WHEN TYPE_NAME(c.system_type_id) IN (''image'',''text'',''ntext'') THEN 1 ELSE 0 END),0) as legacy_col_count,
			ISNULL(SUM(CASE WHEN TYPE_NAME(c.system_type_id) = ''xml''  THEN 1 ELSE 0 END),0) as xml_col_count
		FROM 
			sys.columns c
			INNER JOIN sys.indexes i ON i.object_id = c.object_id
			LEFT OUTER JOIN	sys.index_columns ic ON ic.object_id = c.object_id	AND ic.column_id = c.column_id AND ic.index_id = i.index_id
		WHERE
			(i.index_id = 1               -- index is clustered (count all columns)
			OR ic.index_id is not null)   -- OR nonclustered    (count only index columns)
			GROUP BY 
			c.object_id, i.index_id	
	) c ON c.index_id = i.index_id AND c.object_id = i.object_id
WHERE
	i.index_id > 0 -- we cant rebuild heap
	AND NOT EXISTS	(
		SELECT 1 
		FROM VBMS.dbo.Blacklist bl
		WHERE 
			bl.[database_id] = DB_ID()
			AND (bl.table_id = t.object_id or bl.table_id is null)
			AND (bl.index_id = i.index_id or bl.index_id is null) 
			AND (bl.subsystem_id = 1 or bl.subsystem_id is null)
			AND (bl.partition_n = p.partition_number or bl.partition_n is null)
			AND (bl.worker_name = @worker_name or worker_name is null)
			AND bl.enabled = 1)
	and ps.used_page_count > '+ CAST(@index_minsize /8*1024 as nvarchar(20)) 
EXEC(@SQL)
GO
PRINT N'Creating [dbo].[ProcessQueueAll]...';


GO
/*
-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Oleg Trutnev otrutnev@microsoft.com


Russian:

Процедура обработки очереди заданий в таблице dbo.Tasks.
Задания делятся по подсистемам (subsystem) и типам операций (action_type). Описание в таблице dbo.OperationTypes.
Задания обрабатываются в следующем порядке подсистем: 
1. Обслуживание индексов
2. Обслуживание статистики с предварительным формированием заданий, дабы не обновлять статистику, обновлённую при перестройке индексов.
3. Проверка целостности.
Порядок подсистем неизменен, т.к. представляется единственно разумным.
Внутри каждой подсистемы задания упорядочиваются отдельным образом.
Ведётся учёт остатка времени и предсказание продолжительности операций за счёт статистики прошлых выполнений за месяц по тем же объектам.
Общий лимит времени делится в процентах между подсистемами. Настройки в таблице dbo.Parameters.
После каждой операции выполняется запись показателей времени и результата для дальнейшего использования в прогнозах времени выполнения аналогичных операций.

English:

Stored procedure processes the queue of tasks form dbo.Tasks table.
Tasks are devided by subsystems and action types.
Tasks are processed in specific order:
1. Index maintenance
2. Satistics update (tasks formed prior to execution to exclude stats updated during index rebuild on step 1)
3. Table integrity checks

In each subsystem_id taks are ordered different.
Time is tracked and each operation time consumption is predicted by calculating previous execution times and extropolating it on current size of object.
Total maintenance time is devided between subsystems in percents. See dbo.Parameters.
After each task its duration is saved for future use.

*/

CREATE PROCEDURE [dbo].[ProcessQueueAll] 
	@use_user_db int =1 --process tasks for all online user DB's
	,@use_system_db int = 0 --process tasks for all system DB's
	,@dbname_list nvarchar(500) = '' --list of DB's.
	,@except_list bit = 0 --DB selection inversion
	,@indexes bit = 1
	,@stats bit = 1
	,@checkall bit = 1
	,@checktable bit = 1
	,@checkalloc bit = 1
	,@checkcatalog bit = 1
	,@online_only bit = 1 --perform online operations only
	,@check_backup_state bit = 1
	,@check_ag_state bit = 1
	,@ag_max_queue bigint
	,@afterparty int = 1 --redistribute remaining time in the end. Ex: We spend not all the time during stats update and this time can be used for rebuilding indexes after all operations pass.
	,@add_stats_runtime bit = 1 --It's better to add update statistics tasks after index maintenance, but you may deactivate this feature by passing 0 here.
	,@worker_name nvarchar(255)
	,@total_time BIGINT
	,@index_time BIGINT
	,@check_time BIGINT
	,@stat_time BIGINT
	,@exec_guid uniqueidentifier

AS

SET NOCOUNT ON

DECLARE 
	@command NVARCHAR(max) --выполняемое выражение / command to execute
	,@entry_id INT
	,@subsystem_id INT = 1 --Индексы обслуживаются первыми / Index maintenance first
	,@t1 DATETIME --две переменных @t1 и @t2 нужны для промежуточных расчётов времени / vars for time tracking
	,@finish_time datetime
	,@action_type_id INT
	,@size_mb INT
	,@timefactor FLOAT
	,@table_id INT
	,@index_id INT
	,@partition_number INT
	,@msg NVARCHAR(max)
	,@retention datetime
	,@db int
	,@deadlock_flag bit
	,@exit_code INT
	,@stoplight BIT
	,@log_space BIT
	,@log_space_threshold_mb bigint
	,@error_count int = 0 
	,@null_flag bit = 0
	,@db_backup bit = 0
	,@ag_state bit = 0

	
--Обработка заданий по БД, которых уже нет / Handeling tasks for non-existent DB's

UPDATE dbo.Tasks
SET 
	result = 'DB not found'
	,date_started = date_added
	,date_completed = date_added
where 
	date_completed is null
	AND DB_NAME([database_id]) is null


--Removing the stoplight if it is set somehow.
UPDATE dbo.Workers
SET stoplight = 0
WHERE 
	worker_name = @worker_name
	AND stoplight <> 0

--Row in WorkerSessions might remain from terminated execution
DELETE FROM dbo.[WorkerSessions] 
WHERE worker_name = @worker_name AND session_id = @@SPID

INSERT dbo.[WorkerSessions] (worker_name,session_id, program_name)
select @worker_name,@@SPID, program_name from sys.dm_exec_sessions where session_id=@@SPID

--Инициализация параметров / Loading parameters
IF (@index_time is not null or @stat_time is not null or @check_time is not null)
	BEGIN
	SET @null_flag = 1
	END

IF @total_time is null
BEGIN
	SELECT @total_time = int_value * 60 --перевод из минут в миллисекунды / from minutes to milliseconds
	FROM dbo.Parameters
	WHERE parameter = 'TotalMaintenanceWindowMm' --общее время на обслуживание / Total maintenace time
END
ELSE
	BEGIN
	SET @total_time = @total_time * 60
	END

--Print 'Total time:'
--Print @total_time

IF @index_time is null and @null_flag = 0
BEGIN
	SELECT @index_time = @total_time * int_value / 100
	FROM --расчёт значений в миллисекундах, параметры хранятся в процентах от общего времени. / From percents of total time to milliseconds.
	dbo.Parameters
	WHERE parameter = 'IndexMaintenanceWindowPercent' --время, отведённое на обслуживание индексов. Параметр хранится в процентах от общего времени./ Index maintenance time. Stored as percents of total maintenance time
END
ELSE IF @index_time is null and @null_flag = 1
	SET @index_time = 0
ELSE
	SET @index_time = @total_time * @index_time / 100


--Print 'Index time'
--Print @index_time

IF @check_time is null and @null_flag = 0
BEGIN
	SELECT @check_time = @total_time * int_value / 100
	FROM dbo.Parameters
	WHERE parameter = 'CheckWindowPercent' --время, отведённое на проверку целостности. Параметр хранится в процентах от общего времени. / Integrity checks time. Stored as percents of total maintenance time
END
ELSE IF
	@check_time is null and @null_flag = 1
	SET @check_time = 0
ELSE 
	SET @check_time = @total_time * @check_time / 100


--Print 'Check Time'
--Print @check_time

IF @stat_time is null and @null_flag = 0
BEGIN
	SELECT @stat_time = @total_time * int_value / 100
	FROM dbo.Parameters
	WHERE parameter = 'StatMaintenanceWindowPercent' --время, отведённое на обслуживание статистки. Параметр хранится в процентах от общего времени. / Statistics maintenance time. Stored as percents of total maintenance time
END
ELSE IF @stat_time is null and @null_flag = 1
	SET @stat_time = 0
ELSE
	SET @stat_time = @total_time * @stat_time / 100


--Print 'Stat time'
--Print @stat_time

IF @stat_time+@index_time+@check_time>@total_time
	BEGIN
	RAISERROR('Error during parameters check. Sum of index_time, check_time and stat_time cannot be more than total time!',16,1)
	RETURN
	END




SELECT @log_space_threshold_mb = int_value
FROM dbo.Parameters 
WHERE parameter = 'TranLogSpaceThresholdMb'

--Формирование списка обслуживаемых БД \ Creating a list of DB being optimized

DECLARE @db_list TABLE
(
	database_id int
)

INSERT @db_list
SELECT database_id 
FROM dbo.GetDbList(@use_system_db, @use_user_db, @dbname_list, @except_list) t



DECLARE @operation_types TABLE (
	subsystem_id int,
	action_type_id int,
	finish_time datetime --Время, до которого можно исполнять задания такого типа
)

DECLARE @start_time datetime = getdate()

INSERT INTO @operation_types SELECT 1,1,DATEADD(s, @index_time, @start_time) WHERE @indexes = 1 AND @online_only = 0
INSERT INTO @operation_types SELECT 1,2,DATEADD(s, @index_time, @start_time) WHERE @indexes = 1
INSERT INTO @operation_types SELECT 1,3,DATEADD(s, @index_time, @start_time) WHERE @indexes = 1

INSERT INTO @operation_types SELECT 2,1,DATEADD(s, @index_time+@stat_time, @start_time) WHERE @stats = 1

INSERT INTO @operation_types SELECT 3,1,DATEADD(s, @index_time+@stat_time+@check_time, @start_time) WHERE @checkall = 1 OR @checkcatalog = 1
INSERT INTO @operation_types SELECT 3,2,DATEADD(s, @index_time+@stat_time+@check_time, @start_time) WHERE @checkall = 1 OR @checkalloc = 1
INSERT INTO @operation_types SELECT 3,3,DATEADD(s, @index_time+@stat_time+@check_time, @start_time) WHERE @checkall = 1 OR @checktable = 1


SET @afterparty = ~CAST(@afterparty  as bit)  --Инвертируем afterparty. 0 - два прогона цикла, т.е. обычный+afterparty, 1 - один прогон цикла без afterparty.

 --При первой итерации этого цикла происходит обычная обработка,
 --а при второй - !!AFTERPARTY!! (dancing smile) (drunken smile)
 --First iteration is normal mode, second - afterparty

WHILE @afterparty < 2 
BEGIN

	SET @subsystem_id = 1

	--Цикл по подсистемам. Нужен чтобы между индексами и статистикой обновить задачи на статистику
	WHILE @subsystem_id < 4
	BEGIN

		--Очередь заданий по сбору статистики следует формировать сразу после перестройки индексов, т.к. часть статистик будет уже обновлена, а часть ещё нет.  
		--Statistics maintenance tasks should be added right before execution, because some of statistics will be updated during index maintenance.
		IF @subsystem_id = 2 and @add_stats_runtime = 1 and @stats = 1
		BEGIN

			DECLARE DB CURSOR
			FOR SELECT database_id from @db_list
				
			OPEN DB

			FETCH NEXT FROM DB INTO @db

			WHILE @@FETCH_STATUS = 0
			BEGIN
				EXEC [dbo].[FillQueueStat] @db
				FETCH NEXT FROM DB INTO @db
			END

			CLOSE DB
			
			DEALLOCATE DB
		
		END

		--This cursor iterates over tasks
		DECLARE command CURSOR
		FOR
		SELECT 
			t1.entry_id
			,t1.[database_id]
			,t1.command
			,t1.subsystem_id
			,t1.action_type_id
			,t1.size_mb
			,t1.table_id
			,t1.index_id
			,t1.partition_n
			,t2.finish_time
		FROM 
			dbo.Tasks t1
			INNER JOIN @operation_types t2 ON t1.subsystem_id = t2.subsystem_id AND t1.action_type_id = t2.action_type_id
		WHERE 1=1 
			AND t1.subsystem_id = @subsystem_id
			AND date_started IS NULL
			AND date_completed IS NULL --невыполненные задания заданного типа / Not completed tasks of each type
			AND [database_id] in (select database_id from @db_list) --Только указанные БД / Selected DBs only
		ORDER BY 
			CASE 
				WHEN @subsystem_id = 3 THEN t1.action_type_id
				ELSE NULL
			END
			,t1.[priority] --Этот столбец определяет, в каком порядке выполнять таски внутри группы.
			, CASE --для каждой подсистемы свой порядок сортировки заданий / Each subsystem_id uses it's own tasks sorting
				WHEN @subsystem_id = 1
					THEN entry_id
				END --просто по порядку, задания в очереди в порядке убывания критичности. / by entry_id. Tasks have been sorted while insertion.
			,CASE 
				WHEN @subsystem_id = 2
					THEN rowmod_factor
				END DESC -- в порядке убывания значения превышения порога перерасчёта статистики. rowmod_factor - это на сколько процентов превышен порог. / By rowmod_factor. It's a percent of dynamic threshold violation.
			,CASE 
				WHEN @subsystem_id = 3
					THEN checked_daysago
				END DESC --В порядке убывания количества дней с момента последней проверки / In descending order of days since last integrity check.
			,CASE 
				WHEN @subsystem_id = 3
					AND checked_daysago IS NULL
					THEN size_mb --если проверки не проводилось, то начинаем с самых маленьких / If tables has not been checked at all, then start with the smallest.
				END

		OPEN command

		FETCH NEXT
		FROM command
		INTO @entry_id
			,@db
			,@command
			,@subsystem_id
			,@action_type_id
			,@size_mb
			,@table_id
			,@index_id
			,@partition_number
			,@finish_time


		WHILE @@FETCH_STATUS = 0
		BEGIN

			IF NOT EXISTS (SELECT 1 FROM dbo.Workers WHERE worker_name = @worker_name and stoplight = 0)
			BEGIN
				SET @stoplight = 1
				BREAK
			END

			IF EXISTS (select 1 from dbo.Tasks (nolock) where entry_id = @entry_id and (worker_name is NULL or worker_name = @worker_name)) --Task is not started by another worker
			BEGIN
		
				IF @subsystem_id  = 1 --Index operations may require some logspace.
					BEGIN
					EXEC @log_space = dbo.CheckLogSpaceLeft @db, @log_space_threshold_mb 
					IF @check_backup_state = 1
						BEGIN
						SELECT @db_backup = dbo.GetDBBackupState(@db) --check if backup is running for current database
						END
						ELSE SET @db_backup = 0	
					IF (@@MicrosoftVersion/0x01000000)>=11 and @check_ag_state = 1
						BEGIN 
						SELECT @ag_state = dbo.GetAGSyncState(@db,@ag_max_queue)
						END
					ELSE SET @ag_state = 0
					END
				ELSE 
					BEGIN
					SET @log_space = 1 --Stats operations does not generate so many log records
					SET @db_backup = 0
					SET @ag_state = 0
					END
				SET @t1 = getdate() --засекаем время начала шага / Save the task beginning time

				-- рассчитываем сколько времени может потребоваться для выполнения данного шага
				-- на основе сведений о продолжительности прошлых выполнений аналогичной операции над тем же объектом
				-- Predicting how much time step can take basing on similar tasks execution time (same subsystem, same action type and same object).
				SELECT @timefactor = ISNULL(dbo.GetTimeFactor(@db,1,@table_id,@index_id,@partition_number,@subsystem_id, @action_type_id,60,1),0) 

				IF	DATEADD(s, (@size_mb * @timefactor), @t1) < @finish_time 
					AND @log_space = 1 and @db_backup = 0 and @ag_state = 0--если остатка времени и места под логи предположительно хватит на выполнение команды и бэкап не помешает. / Check if we have enough time and log space to execute the task adn the database backup will not interfere
				BEGIN
	
					UPDATE dbo.Tasks
					SET 
						date_started = getdate()
						,worker_name = @worker_name
						,[execution_id] = @exec_guid
					WHERE 
						entry_id = @entry_id

					SET @msg = 'Ok' --Если не произойдёт ошибки, то результатом выполнения операции будет Ok. / Setting Ok as a default exit message.
					SET @deadlock_flag = 0
					SET @exit_code = 1

					BEGIN TRY
						UPDATE dbo.[WorkerSessions]
						SET 
							subsystem_id = @subsystem_id, 
							entry_id = @entry_id
						WHERE 
							worker_name = @worker_name
						--PRINT @command
						EXEC (@command)
					END TRY

					BEGIN CATCH

						SET @exit_code = ERROR_NUMBER()
				
						IF ERROR_NUMBER() in (1205,1222,1912)
							SET @deadlock_flag = 1
				
						SET @msg = N'Error code: ' + CAST(ERROR_NUMBER() AS NVARCHAR(10)) + N'. Error message:' + ERROR_MESSAGE()

						PRINT 'Error execuring "'+@command+'"   '+@msg

						SET @error_count += 1 --Global flag indicating that there were at least one error

					END CATCH

					--IF @msg = 'Ok'
					--BEGIN
					--SET @msg = 'Ok' + '. Time prognose was: '+CAST((@size_mb * @timefactor) as NVARCHAR(50)) + ' sec.'
					--END

					UPDATE dbo.Tasks
					SET 
						date_completed = GETDATE()
						,duration_s = DATEDIFF(ss, date_started, GETDATE())
						,time_factor = CASE WHEN @exit_code = 1 THEN (DATEDIFF(ms, date_started, GETDATE()) / 1000.0 / (size_mb + 1.0)) ELSE NULL END
						,result = @msg
						,exit_code = @exit_code
					WHERE 
						entry_id = @entry_id
	
					SELECT @stoplight = stoplight FROM dbo.Workers WHERE worker_name = @worker_name
		
				END 
				ELSE
				BEGIN

					IF @log_space = 0 --If not enougth log space
						UPDATE dbo.Tasks
						SET 
							worker_name = @worker_name
							,[execution_id] = @exec_guid
							,date_started = GETDATE()
							,date_completed = GETDATE()
							,duration_s = 0
							,result = 'Skipped. Not enough transaction log space'
							,exit_code = -2
						WHERE 
							entry_id = @entry_id

					IF @db_backup = 1--If backup is running and we need to stop due to that
						UPDATE dbo.Tasks
						SET 
							worker_name = @worker_name
							,[execution_id] = @exec_guid
							,date_started = GETDATE()
							,date_completed = GETDATE()
							,duration_s = 0
							,result = 'Skipped. Database Backup is running and this worker is configured to skip in this case'
							,exit_code = -2
						WHERE 
							entry_id = @entry_id
					IF @ag_state =1--If AG is not healthy or can't keep up with the pace
						UPDATE dbo.Tasks
						SET 
							worker_name = @worker_name
							,[execution_id] = @exec_guid
							,date_started = GETDATE()
							,date_completed = GETDATE()
							,duration_s = 0
							,result = 'Skipped. One of the AG replicas cant keep up with the log growth or is unhealthy'
							,exit_code = -2
						WHERE 
							entry_id = @entry_id
					

					IF DATEADD(SECOND, (@size_mb * @timefactor ), @t1) > @finish_time  --Недостаточно времени 
						AND @afterparty = 1                                             --Мы уже на второй итерации (на первой мы просто пропускаем таск)
						UPDATE dbo.Tasks
						SET 
							worker_name = @worker_name
							,[execution_id] = @exec_guid
							,date_started = GETDATE()
							,date_completed = GETDATE()
							,duration_s = 0
							,result = 'Skipped. Not enough time left'
							,exit_code = -1
						WHERE 
							entry_id = @entry_id
				END
		
			END --If task started by another worker
			-- We simply skip those tasks, because other worker "owns" them 

		
			FETCH NEXT
			FROM command
			INTO @entry_id
				,@db
				,@command
				,@subsystem_id
				,@action_type_id
				,@size_mb
				,@table_id
				,@index_id
				,@partition_number
				,@finish_time
		END

		CLOSE command

		DEALLOCATE command

		IF @stoplight = 1
			BREAK

		SET @subsystem_id += 1
	END
	
	IF @stoplight = 1
		BREAK

	IF @afterparty = 0
	BEGIN
		--Мы прогнали основной цикл один раз, потратив на каждую из стадий отведенное время
		--При этом, возможно мы пропустили некоторые шаги т.к. кончилось время соответствующей стадии
		--Теперь мы можем повторить все еще раз и все-таки выполнить их

		--Снимаем постадийное ограничение
		UPDATE @operation_types
		SET	finish_time = (SELECT max(finish_time) FROM @operation_types)
	
	END

	SET @afterparty = @afterparty + 1 --После второго захода надо завязывать, иначе потом будет болеть голова

END


--Праздник закончился, пора наводить порядок.
--В норме к этому моменту не должно остаться ни одного необработанного таска, кроме как в случае когда мы принудительно остановили воркер
--Тем не менее, здесь мы проверяем, не осталось ли таких тасков и прописываем в них коды ошибок.

--Afterparty is over. It's time to clean up.
--Normally, there should be no unprocessed tasks at this point, only exclusion is if the worker was stopped via stoplight.
--Here we set errorcode to all unprocessed tasks to simplify troubleshoting

UPDATE t1
SET 
	worker_name = @worker_name
	,[execution_id] = @exec_guid
	,date_started = GETDATE()
	,date_completed = GETDATE()
	,duration_s = 0
	,result = CASE WHEN @stoplight = 0 THEN 'Skipped. Reason is unknown' ELSE 'Skipped. User requested to stop' END
	,exit_code = CASE WHEN @stoplight = 0 THEN -4 ELSE -3 END -- There should be no -4 at all! -4 means some bug!
FROM 
	dbo.Tasks t1
	INNER JOIN @operation_types t2 ON t1.subsystem_id = t2.subsystem_id AND t1.action_type_id = t2.action_type_id
WHERE 
	date_completed is null
	and [database_id] in (select database_id from @db_list)
	and worker_name is null

IF @stoplight = 1
BEGIN
	UPDATE dbo.Workers
	SET stoplight = 0
	WHERE worker_name = @worker_name
	AND stoplight <> 0
END

--Calculate the expected execution time (for consistency only due to some stats tasks where generated runtime)

DECLARE TASKS CURSOR
FOR SELECT entry_id, [database_id], table_id,index_id,partition_n,subsystem_id, action_type_id
FROM dbo.Tasks WHERE time_prognosis_s is null


OPEN TASKS

FETCH NEXT FROM TASKS
INTO @entry_id,@db,@table_id,@index_id,@partition_number,@subsystem_id,@action_type_id

WHILE @@FETCH_STATUS = 0 
BEGIN 

UPDATE dbo.Tasks
SET time_prognosis_s = ISNULL(dbo.GetTimeFactor(@db,1,@table_id,@index_id,@partition_number,@subsystem_id, @action_type_id,60,1),0) * size_mb
WHERE entry_id = @entry_id
FETCH NEXT FROM TASKS
INTO @entry_id,@db,@table_id,@index_id,@partition_number,@subsystem_id,@action_type_id

END

CLOSE TASKS
DEALLOCATE TASKS




DELETE FROM dbo.[WorkerSessions]
WHERE worker_name = @worker_name

RETURN @error_count
GO
PRINT N'Creating [dbo].[FillQueueAll]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Oleg Trutnev otrutnev@microsoft.com
		Arseny Birukov arsbir@microsoft.com

Procedure is a wrapper for FillQueueXXX procedures that passes neccessary parameters to them.

*/
CREATE PROCEDURE [dbo].[FillQueueAll] 
	-- Add the parameters for the stored procedure here
	@worker_name nvarchar(50) = NULL, --generate tasks only for a specific worker profile.
	@indexes bit = 1,
	@async_frag_collection bit =1,
	@collect_frag_now int =1, -- 0-dont collect frag data, only prepare indexes list, 1- prepare indexes list, collect frag data and generate tasks in this session. 2 - Indexes list with frag data has been filled already, need just to prepare the tasks. 
	@stats bit = 0,
	@stats_sample nvarchar(50) = 'RESAMPLE',
	@checkall bit = 1,
	@checktable bit = 0,
	@table_max_size_mb bigint = 1000000,
	@checkalloc bit = 0,
	@checkcatalog bit = 0,
	@use_user_db bit = 1,
	@use_system_db bit = 0,
	@dbname_list nvarchar(500) = '',
	@except_list bit =0, --invert database selection list
	@sortintempdb bit = NULL,
	@ix_maxdop int = NULL, --override global settings maxDOP.	
	@clear_latch bit = 0
	,@debug bit = 0
	
	
AS
BEGIN
	
	SET NOCOUNT ON;
	
	DECLARE 
		@dbint_id int
		,@batch UNIQUEIDENTIFIER
		,@db INT
		,@tableid INT
		,@indexid INT
		,@partitionnum INT
		,@subsystem_id INT
		,@actiontype INT
		,@entryid BIGINT
		,@frag_collection_time_limit_s int
		,@retention DATETIME

	SET @batch = NEWID()

	IF @worker_name is NOT NULL
		IF (select latched_spid FROM dbo.Workers WHERE worker_name = @worker_name) in (0,@@SPID) or @clear_latch = 1
		BEGIN
			SELECT 
				@indexes = [indexes]
				,@stats = [stats]
				,@stats_sample =  stats_sample
				,@checkall = checkall
				,@checktable = checktable
				,@checkalloc = checkalloc
				,@checkcatalog = checkcatalog
				,@use_system_db = use_system_db
				,@use_user_db = use_user_db
				,@dbname_list = dbname_list
				,@except_list = except_list
				,@frag_collection_time_limit_s = frag_eval_time_limit_s
			FROM dbo.Workers
			WHERE worker_name = @worker_name

			UPDATE dbo.Workers
			SET latched_spid = @@SPID
			WHERE worker_name = @worker_name
		END
		ELSE
		BEGIN 
			RAISERROR('FillQueueAll is already running for this worker!',16,1);
			RETURN
		END
	
	DELETE FROM dbo.[WorkerSessions]
WHERE not exists(
	select 1 from sys.dm_exec_sessions es 
		where es.session_id = dbo.[WorkerSessions].session_id 
		and es.program_name COLLATE DATABASE_DEFAULT = dbo.[WorkerSessions].program_name COLLATE DATABASE_DEFAULT
		and es.status in ('running','runnable','suspended')
		and es.session_id <> @@SPID
		)
		
	
	IF @worker_name is not null
	INSERT dbo.[WorkerSessions] (worker_name,session_id, program_name,subsystem_id)
	select @worker_name,@@SPID, program_name,0 from sys.dm_exec_sessions where session_id=@@SPID

	IF @ix_maxdop IS NULL
		SELECT @ix_maxdop = int_value
		FROM dbo.Parameters
		WHERE parameter = 'MaxDop'

	IF @sortintempdb IS NULL
		SELECT @sortintempdb= int_value
		FROM dbo.Parameters
		WHERE parameter = 'SortInTempdb'


	IF @frag_collection_time_limit_s is NULL
		SELECT @frag_collection_time_limit_s = int_value
		FROM dbo.Parameters
		WHERE parameter = 'FragCollectionTimeLimitS'

	--Fill tasks table

	DECLARE DB CURSOR FORWARD_ONLY
	FOR 
	SELECT database_id 
	FROM dbo.GetDbList(@use_system_db, @use_user_db, @dbname_list, @except_list) t

	OPEN DB

	FETCH NEXT FROM DB INTO @dbint_id

	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF @indexes = 1 
			IF @async_frag_collection = 0
				EXEC [dbo].[FillQueueIndex] @dbint_id, @batch, @ix_maxdop, @sortintempdb
			ELSE 
				BEGIN
					DELETE
					FROM dbo.Tasks
					WHERE subsystem_id = 1
					AND date_completed IS NULL
					AND [database_id] = @dbint_id
					
				IF @collect_frag_now = 2
					BEGIN
					EXEC [dbo].[FillQueueIndex_async] @dbint_id,@batch,@ix_maxdop,@sortintempdb 
					END
				ELSE
				EXEC [dbo].[CollectIndexData] @dbint_id, @batch
				IF @collect_frag_now = 1
					BEGIN 
						EXEC [dbo].[CollectIndexFragData] @dbint_id,@frag_collection_time_limit_s,@batch,@ix_maxdop,@sortintempdb
						--EXEC [dbo].[FillQueueIndex_async] @dbint_id,@batch,@ix_maxdop,@sortintempdb
					END
				IF @collect_frag_now = 0
				PRINT 'Index frag data needs to be collected in a separate session according to @collect_frag_now = 0. 
				Collect frag data by running  dbo.CollectIndexFragData (may be run in several parallel sessions) and rerun FillQueueAll with @async_frag_collection = 1 and @collect_frag_now = 1'	
			END

		IF ((@checkall = 1 or @checktable = 1) and @checktable <> 0)
			EXEC [dbo].[FillQueueCheckTable] @dbint_id, @batch, @table_max_size_mb

		IF ((@checkall = 1 or @checkcatalog = 1 ) and @checkcatalog <> 0) 
			EXEC [dbo].[FillQueueCheckCatalog] @dbint_id, @batch

		IF ((@checkall = 1 or @checkalloc = 1) and @checkalloc <> 0)
			EXEC [dbo].[FillQueueCheckAlloc] @dbint_id, @batch

		IF (@stats = 1)
			EXEC [dbo].[FillQueueStat] @dbint_id, @batch, @sample = @stats_sample

		FETCH NEXT FROM DB INTO @dbint_id
	END

	CLOSE DB
	DEALLOCATE DB

	--Calculate the expected execution time

	DECLARE TASKS CURSOR
	FOR SELECT entry_id, [database_id], table_id,index_id,partition_n,subsystem_id, action_type_id
	FROM dbo.Tasks WHERE time_prognosis_s is null

	OPEN TASKS

	FETCH NEXT FROM TASKS
	INTO @entryid, @db, @tableid, @indexid, @partitionnum, @subsystem_id, @actiontype

	WHILE @@FETCH_STATUS = 0 
	BEGIN 

		UPDATE dbo.Tasks
		SET time_prognosis_s = ISNULL(dbo.GetTimeFactor(@db,1, @tableid, @indexid, @partitionnum, @subsystem_id, @actiontype, 60, 1), 0) * size_mb
		WHERE entry_id = @entryid

		FETCH NEXT FROM TASKS
		INTO @entryid, @db, @tableid, @indexid, @partitionnum, @subsystem_id, @actiontype

	END

	CLOSE TASKS

	DEALLOCATE TASKS

	UPDATE dbo.Workers
		SET latched_spid = 0
		WHERE worker_name = @worker_name

	SELECT @batch as BatchId

	IF @debug = 1
	BEGIN
		SELECT 'Frag analysis results' as [-----]
		SELECT * FROM dbo.FragmentationData where batch_id = @batch
		SELECT 'Tasks generated' as [-----]
		SELECT * from dbo.Tasks where batch_id = @batch
	END


--Удаление старых записей / Removing old records
IF EXISTS (SELECT 1 FROM dbo.Parameters WHERE parameter = 'HistoryRetentionDays' and int_value is not null )
	SELECT @retention = dateadd(DD,-int_value,getdate()) 
	FROM dbo.Parameters
	WHERE parameter = 'HistoryRetentionDays'

IF EXISTS (SELECT 1 FROM dbo.Parameters WHERE parameter = 'HistoryRetentionDays' and int_value is not null )
BEGIN
	DELETE FROM dbo.Tasks
	WHERE date_added < @retention

	DELETE FROM dbo.DBCCChecksLog
	WHERE log_date < @retention

	DELETE FROM dbo.FragmentationData
	WHERE collection_date < @retention
END
DELETE FROM dbo.WorkerSessions where worker_name = @worker_name and subsystem_id = 0

END
GO
PRINT N'Creating [dbo].[StartWorker]...';


GO
/*
-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Oleg Trutnev otrutnev@microsoft.com


Russian:
Хранимая процедура запуска заданий обслуживания с заранее сохраненным набором параметров. 
Сначала необходимо заполнить профиль в таблице Workers. Все поля обязательны, кроме date_added.
После сохранения профиля значение worker_name может быть использовано для запука задания с этими параметрами.

English:
Procedure starts maintenance tasks execution from queue with parameters, saved to dbo.Workers table.
All the fields there should be filled except date_added.
Then the worker_name can be used to start workers with this parameters.

*/

CREATE PROCEDURE [dbo].[StartWorker] 
	@worker_name nvarchar(255),
	@exec_guid uniqueidentifier = null
AS
SET NOCOUNT ON
DECLARE 
	@use_user_db1 bit
	,@use_system_db1 bit
	,@dbname_list1 nvarchar(500)
	,@except_list1 bit
	,@indexes1 bit
	,@stats1 bit 
	,@checkall1 bit
	,@checktable1 bit
	,@checkalloc1 bit
	,@checkcatalog1 bit
	,@online_only1 bit
	,@check_backup_state1 bit
	,@check_ag_state1 bit
	,@ag_max_queue1 bigint
	,@afterparty1 bit
	,@add_stats_runtime1 bit
	,@totaltimemin1 bigint
	,@indextime1 bigint
	,@stattime1 bigint
	,@checktime1 bigint

IF @exec_guid is null
	SET @exec_guid = NEWID()

IF NOT EXISTS (SELECT 1 FROM dbo.Workers where worker_name = @worker_name)
	BEGIN
	RAISERROR('No such worker registered! Please note the case of letters.',16,1)
	RETURN
	END
ELSE
BEGIN
SELECT 
	@use_user_db1 = [use_user_db]
	,@use_system_db1 =[use_system_db]
	,@dbname_list1 = [dbname_list]
	,@except_list1 =[except_list]
	,@indexes1 = [indexes]
	,@stats1 = [stats]
	,@checkall1 = [checkall]
	,@checktable1 = [checktable]
	,@checkalloc1 = [checkalloc]
	,@checkcatalog1 =[checkcatalog]
	,@online_only1 = [online_only]
	,@check_backup_state1 = [check_backup_state]
	,@check_ag_state1 =[check_ag_state]
	,@ag_max_queue1 = [ag_max_queue]
	,@afterparty1 = [afterparty]
	,@add_stats_runtime1 = [add_stats_runtime]
	,@totaltimemin1 = [totaltimemin]
	,@indextime1 = [indextime]
	,@stattime1 = [stattime]
	,@checktime1 = [checktime]
FROM 
	dbo.Workers
where 
	[worker_name] = @worker_name


--Clean WorkerSession. Just in case....	  
DELETE FROM dbo.[WorkerSessions]
WHERE not exists(
	select 1 from sys.dm_exec_sessions es 
		where es.session_id = dbo.[WorkerSessions].session_id 
		and es.program_name COLLATE DATABASE_DEFAULT = dbo.[WorkerSessions].program_name COLLATE DATABASE_DEFAULT
		and es.status in ('running','runnable','suspended'))


EXEC dbo.ProcessQueueAll
	@use_user_db = @use_user_db1
	,@use_system_db =@use_system_db1
	,@dbname_list = @dbname_list1
	,@except_list =@except_list1
	,@indexes = @indexes1
	,@stats = @stats1 
	,@checkall = @checkall1
	,@checktable = @checktable1
	,@checkalloc = @checkalloc1
	,@checkcatalog =@checkcatalog1
	,@online_only = @online_only1
	,@check_backup_state = @check_backup_state1
	,@check_ag_state = @check_ag_state1
	,@ag_max_queue = @ag_max_queue1
	,@afterparty = @afterparty1
	,@add_stats_runtime = @add_stats_runtime1
	,@worker_name = @worker_name
	,@total_time = @totaltimemin1
	,@index_time = @indextime1
	,@stat_time = @stattime1
	,@check_time = @checktime1
,@exec_guid = @exec_guid

END
GO
-- Refactoring step to update target server with deployed transaction logs

IF OBJECT_ID(N'dbo.__RefactorLog') IS NULL
BEGIN
    CREATE TABLE [dbo].[__RefactorLog] (OperationKey UNIQUEIDENTIFIER NOT NULL PRIMARY KEY)
    EXEC sp_addextendedproperty N'microsoft_database_tools_support', N'refactoring log', N'schema', N'dbo', N'table', N'__RefactorLog'
END
GO
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'a773a8be-6638-4df5-992d-1908eadc217e')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('a773a8be-6638-4df5-992d-1908eadc217e')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '05b662bc-24c2-4ec3-9fe5-296612e30c65')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('05b662bc-24c2-4ec3-9fe5-296612e30c65')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b8493958-1f98-4118-806a-c5fd90e0ffc2')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b8493958-1f98-4118-806a-c5fd90e0ffc2')

GO

GO
DECLARE @Ops TABLE ([subsystem_id] int, [action_type_id]int, [subsystem_name] nvarchar(255), [action_type_name] nvarchar(255))
DECLARE @Params TABLE ([parameter] nvarchar(50), [string_value] nvarchar(150), [int_value] BIGINT, [float_value] FLOAT (53), [description] NVARCHAR (MAX) )

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (0, 1, N'Queue Generation', N'Generation of tasks for further execution')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (1, 1, N'Index Maintenance\Обслуживание индексов', N'Offline rebuild\Перестройка индекса оффлайн')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (1, 2, N'Index Maintenance\Обслуживание индексов', N'Online rebuild\Перестройка индекса онлайн')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (1, 3, N'Index Maintenance\Обслуживание индексов', N'Reorganize\Реорганизация индекса')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (2, 1, N'Statistics maintenance\Обслуживание статистики', N'Update statistics\Пересчёт статистки')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (3, 1, N'Integrity check\Проверка целостности', N'CHECKCATALOG\Проверка целостности системного каталога')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (3, 2, N'Integrity check\Проверка целостности', N'CHECKALLOC\Проверка целостности в части размещения (DBCC CHECKALLOC)')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (3, 3, N'Integrity check\Проверка целостности', N'CHECKTABLE\Проверка целостности отдельной таблицы')


INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckTableIntervalDays', NULL, 7, NULL, N'Days between CHECKTABLE\Периодичность проверки целостности отдельно взятой таблицы')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'MaxDop', NULL, 2, NULL, N'Max Degree of parallelism for index operations\Количество ядер, которые могут быть использованы для операций с индексами')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckCatalogIntervalDays', NULL, 7, NULL, N'Days between CHECKCATALOG\Периодичность проверки целостности системных таблиц БД')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'HistoryRetentionDays', NULL, 90, NULL, N'Old tasks will be removed after this number of days\Продолжительность хранения журнала заданий')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexReorgThresholdPercent', NULL, 30, NULL, N'Maximum index fragmentation when reorganize is prefered instead of rebuild\Максимальное значение фрагментации индекса для использования REORGANIZE')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexOnlineRebuild', NULL, 1, NULL, N'Use or not ONLINE where possible. Online operations are slower\Флаг использования ONLINE при перестройке индексов. Его использование увеличивает продолжительность операции, но сохраняет индекс доступным по время обслуживания')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'TotalMaintenanceWindowMm', NULL, 60, NULL, N'Total amount of time (minutes) for maintenance\Общая продолжительность технологического окна в минутах')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexMaintenanceWindowPercent', NULL, 30, NULL, N'Percent of time to spend on index maintenance\Процент времени, отведённого под обслуживание индексов')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'StatMaintenanceWindowPercent', NULL, 30, NULL, N'Percent of time to spend on statistics maintenance\ Процент времени, отведённого под обслуживание статистики')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckWindowPercent', NULL, 30, NULL, N'Percent of time to spend on integrity checks\Процент времени, отведённого под проверку целостности')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckAllocIntervalDays', NULL, 7, NULL, N'Days between CHECKALLOC\Периодичность проверки целостноси в части аллокации экстентов')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'LockTimeoutMs', NULL,20000 , NULL, N'How long (ms) should index operation wait being locked\Максимальное время в заблокированном состоянии. При превышении задание будет остановлено.')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'SortInTempdb', NULL,0 , NULL, N'Should indexes be sorted in tempdb during index rebuild?\Использование tempdb для сортировки индекса во время перестройки')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexFragLowerThreshold', NULL,10 , NULL, N'Index fragmentation lower limit. Index with fragmentation lower than this wont be maintaintes \ Нижняя граница фрагментации. Индекс с меньшей фрагментацией обслуживаться не будет')
INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'TranLogSpaceThresholdMb', NULL,500 , NULL, N'Transaction log space left threshold(mountpoints not supported yet)/Минимальный размер свободного места под лог транзакций для операций обслуживания индексов (mountpoint не поддерживается пока)')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexMinimumSizeMB', NULL,10 , NULL, N'Minimum size of index that can be rebuilt or reorganized/Минимальный размер индекса, подлежащего обслуживанию')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'FragCollectionTimeLimitS', NULL,3600 , NULL, N'Maximum duration of index fragmentation analysis phase/Максимальная продолжительность фазы анализа фрагментации индексов')

MERGE dbo.Parameters as TARGET
USING (SELECT * FROM @Params) as SOURCE ([parameter], [string_value], [int_value], [float_value], [description])
ON (TARGET.parameter COLLATE DATABASE_DEFAULT = SOURCE.parameter COLLATE DATABASE_DEFAULT)
WHEN MATCHED THEN UPDATE SET description = SOURCE.description
WHEN NOT MATCHED THEN INSERT ([parameter], [string_value], [int_value], [float_value], [description])
VALUES (SOURCE.[parameter], SOURCE.[string_value], SOURCE.[int_value], SOURCE.[float_value], SOURCE.[description]);



MERGE dbo.OperationTypes as TARGET
USING (SELECT * FROM @Ops) as SOURCE ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name])
ON (TARGET.subsystem_id = SOURCE.subsystem_id and TARGET.action_type_id = SOURCE.action_type_id)

WHEN MATCHED THEN UPDATE SET subsystem_name = SOURCE.subsystem_name, action_type_name = SOURCE.action_type_name
WHEN NOT MATCHED THEN INSERT ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name])
VALUES (SOURCE.[subsystem_id], SOURCE.[action_type_id], SOURCE.[subsystem_name], SOURCE.[action_type_name]);



INSERT dbo.DbVersion (Version,DateInstalled) VALUES ('2.0.2.5 Alpha',getdate())
GO

UPDATE VBMS.dbo.Tasks 
SET exit_code = -1
WHERE result = 'Skipped. Not enough time left'
and exit_code is null


/*

changelog:
2.0.2.5a
	- FIX: 3 entries for a non-partitioned clustered index
	- FIX: Clustered columnstore index statistics update tasks where generated which are not possible to execute.
	- FIX: Statistics update tasks are generated with no regard to personal blacklist entries (worker_name field is ignored)
	- FIX: Stats that were added during execution loop has unrealisticly prescise time prognosis due to post-execution evaluation

2.0.2.4b
	- Added volume_mount_point to collection to improve future prediction model
	- FillQueueAll - added @debug parameter. If @debug = 1 procedure returns the list of frag analysis results and tasks generated
2.0.2.3b
	- FIX - afterparty does not work. at all. Old stupid typo.
	- dbo.StartWorker - added NOCOUNT ON.

2.0.2.2b
	- Added view dbo.FragAnalysisStatus to view statistics of framentation analysis tasks
	- Added support of creating blacklist items for a specific workers.
	- FIX - apriori timefactors too high 
	- FIX - time_prognosis_s column type changed to bigint to avoid overflow 
	- Tables with 0 records are excluded from checks
	- FillQueue is now managed as a worker
	- FillQueue - frag collection tasks now support LOCK_TIMEOUT feature to avoid hanging on frag collection
	- FIllQueue - frag collection now supports blacklists

*/
GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET MULTI_USER 
    WITH ROLLBACK IMMEDIATE;


GO
PRINT N'Update complete.';


GO
