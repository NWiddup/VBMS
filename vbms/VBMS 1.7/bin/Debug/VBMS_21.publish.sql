/*
Deployment script for VBMS

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "VBMS"
:setvar DefaultFilePrefix "VBMS"
:setvar DefaultDataPath "C:\SQL\MSSQL13.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\SQL\MSSQL13.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'disable';


GO
PRINT N'Altering [dbo].[FillQueueCheckTable]...';


GO
/*
-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Oleg Trutnev otrutnev@microsoft.com


Russian version:

Процедура формирования заданий проверки целостности отдельных таблиц.
Задание представляет собой выражение DBCC CHECKTABLE('<имя таблицы>').
Отбираются таблицы не проверявшиеся более чем количество дней, заданное параметром CheckTableIntervalDays в таблице Parameters.
Таблицы упорядочиваются по давности последней проверки и размеру таблицы.

Englsh version:

Procedure creates a tasks of integrity checks for perticular tables.
Tasks are statements like DBCC CHECKTABLE('<Table name>').
Tables are being scheduled for check if they have not been checked for more than X days,
where X is a value of CheckTableIntervalDays parameter in dbo.Parameters table.
Tasks are sorted by date of last check and table size Mb.

*/
ALTER PROCEDURE [dbo].[FillQueueCheckTable] 
	@db INT, 
	@batch UNIQUEIDENTIFIER, 
	@table_max_size_mb bigint = 1000000 --exclude bigger tables. By default no more than 1 Pb
AS

DECLARE	@SQL NVARCHAR(MAX)

DECLARE @check_interval int

SELECT @check_interval = int_value
FROM dbo.Parameters where parameter = 'CheckTableIntervalDays'


DECLARE @worker_name nvarchar(255)
SELECT @worker_name = worker_name
FROM dbo.WorkerSessions
WHERE session_id = @@SPID

IF @table_max_size_mb = 0
	SET @table_max_size_mb = 1000000

DELETE
FROM dbo.Tasks
WHERE subsystem_id = 3 --Тип действия Проверка целостности таблиц / subsystem_id 3 is an integrity check
	AND action_type_id = 3
	AND date_completed IS NULL
	AND [database_id] = @db


DECLARE @tables TABLE
(
	database_id int,
	schema_id int,
	object_id int,
	object_name nvarchar(4000),
	row_count bigint,
	size_mb decimal(10, 3)
)

SET @SQL = 
'USE '+QUOTENAME(DB_NAME(@db))+
'SELECT 
	DB_ID() as database_id, 
	t.schema_id, 
	t.object_id, 
	QUOTENAME(SCHEMA_NAME(t.schema_id))+''.''+QUOTENAME(OBJECT_NAME(t.object_id)) as object_name,
	sum(p.rows) as row_count,
	sum(CAST(ps.used_page_count * 8 / 1024.00 AS decimal(10, 3))) as size_mb
	
FROM 
	sys.tables t
	INNER JOIN sys.indexes i on t.object_id = i.object_id and i.index_id < 2 --Heap or clustered index
	INNER JOIN sys.partitions p ON p.object_id = t.object_id AND p.index_id = i.index_id
	LEFT JOIN sys.dm_db_partition_stats ps on ps.object_id = t.object_id AND ps.index_id = i.index_id AND ps.partition_number = p.partition_number
WHERE rows > 0
GROUP BY 
	t.schema_id, 
	t.object_id'
	
INSERT INTO @tables
EXEC (@SQL)


INSERT dbo.Tasks (
	[batch_id]
	,[subsystem_id]
	,[action_type_id]
	,[command]
	,[date_added]
	,[database_id]
	,[table_id]
	,[rowcnt]
	,[size_mb]
	,[checked_daysago]
)
SELECT
	@batch
	,3
	,3 
	,N'USE [VBMS]; EXEC [dbo].[ExecuteDBCCCheck] @action_type_id = 3, @db = '+cast(@db as nvarchar(4))+', @object_id = '+cast(nt.object_id as nvarchar(20)) +'; --DBCC CHECKTABLE('+nt.object_name+') WITH NO_INFOMSGS'
	,getdate()
	,@db
	,nt.object_id
	,nt.row_count
	,nt.size_mb
	,DATEDIFF(dd,pt.date_completed,getdate())
FROM
	@tables nt 
	LEFT OUTER JOIN
	( 
		SELECT 
			ROW_NUMBER() OVER (PARTITION BY table_id order by date_completed DESC) AS rn,
			table_id,
			date_completed
		FROM  
			dbo.Tasks
		WHERE 
			subsystem_id = 3
			AND action_type_id = 3
			AND database_id = @db
			AND exit_code = 1
	) pt ON pt.table_id = nt.object_id
WHERE
	ISNULL(nt.size_mb,0) < @table_max_size_mb
	AND (pt.rn = 1 OR pt.rn is null) --last row or nothing
	AND (DATEDIFF(dd,ISNULL(pt.date_completed,0),getdate()) > @check_interval OR pt.date_completed is null)
	AND NOT EXISTS
		(
			SELECT 1 
			FROM dbo.Blacklist bl
			WHERE 
				bl.database_id = @db 
				and (bl.table_id = nt.object_id or bl.table_id is null)
				and (bl.subsystem_id = 3 or bl.subsystem_id is null)
				and (bl.action_type_id = 3 or action_type_id is null)
				AND (bl.worker_name = @worker_name or worker_name is null)
				and bl.enabled = 1
		)
GO
PRINT N'Altering [dbo].[FillQueueAll]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: Oleg Trutnev otrutnev@microsoft.com
		Arseny Birukov arsbir@microsoft.com

Procedure is a wrapper for FillQueueXXX procedures that passes neccessary parameters to them.

*/
ALTER PROCEDURE [dbo].[FillQueueAll] 
	-- Add the parameters for the stored procedure here
	@worker_name nvarchar(50) = NULL, --generate tasks only for a specific worker profile.
	@indexes bit = 1,
	@async_frag_collection bit =1,
	@collect_frag_now int =1, -- 0-dont collect frag data, only prepare indexes list, 1- prepare indexes list, collect frag data and generate tasks in this session. 2 - Indexes list with frag data has been filled already, need just to prepare the tasks. 
	@stats bit = 0,
	@stats_sample nvarchar(50) = 'RESAMPLE',
	@checkall bit = 1,
	@checktable bit = 0,
	@table_max_size_mb bigint = 1000000,
	@checkalloc bit = 0,
	@checkcatalog bit = 0,
	@use_user_db bit = 1,
	@use_system_db bit = 0,
	@dbname_list nvarchar(500) = '',
	@except_list bit =0, --invert database selection list
	@sortintempdb bit = NULL,
	@ix_maxdop int = NULL, --override global settings maxDOP.	
	@clear_latch bit = 0
	
	
AS
BEGIN
	
	SET NOCOUNT ON;
	
	DECLARE 
		@dbint_id int
		,@batch UNIQUEIDENTIFIER
		,@db INT
		,@tableid INT
		,@indexid INT
		,@partitionnum INT
		,@subsystem_id INT
		,@actiontype INT
		,@entryid BIGINT
		,@frag_collection_time_limit_s int
		,@retention DATETIME

	SET @batch = NEWID()

	IF @worker_name is NOT NULL
		IF (select latched_spid FROM dbo.Workers WHERE worker_name = @worker_name) in (0,@@SPID) or @clear_latch = 1
		BEGIN
			SELECT 
				@indexes = [indexes]
				,@stats = [stats]
				,@stats_sample =  stats_sample
				,@checkall = checkall
				,@checktable = checktable
				,@checkalloc = checkalloc
				,@checkcatalog = checkcatalog
				,@use_system_db = use_system_db
				,@use_user_db = use_user_db
				,@dbname_list = dbname_list
				,@except_list = except_list
				,@frag_collection_time_limit_s = frag_eval_time_limit_s
			FROM dbo.Workers
			WHERE worker_name = @worker_name

			UPDATE dbo.Workers
			SET latched_spid = @@SPID
			WHERE worker_name = @worker_name
		END
		ELSE
		BEGIN 
			RAISERROR('FillQueueAll is already running for this worker!',16,1);
			RETURN
		END
	
	DELETE FROM dbo.[WorkerSessions]
WHERE not exists(
	select 1 from sys.dm_exec_sessions es 
		where es.session_id = dbo.[WorkerSessions].session_id 
		and es.program_name COLLATE DATABASE_DEFAULT = dbo.[WorkerSessions].program_name COLLATE DATABASE_DEFAULT
		and es.status in ('running','runnable','suspended')
		and es.session_id <> @@SPID
		)
		
	
	
	INSERT dbo.[WorkerSessions] (worker_name,session_id, program_name,subsystem_id)
	select @worker_name,@@SPID, program_name,0 from sys.dm_exec_sessions where session_id=@@SPID

	IF @ix_maxdop IS NULL
		SELECT @ix_maxdop = int_value
		FROM dbo.Parameters
		WHERE parameter = 'MaxDop'

	IF @sortintempdb IS NULL
		SELECT @sortintempdb= int_value
		FROM dbo.Parameters
		WHERE parameter = 'SortInTempdb'


	IF @frag_collection_time_limit_s is NULL
		SELECT @frag_collection_time_limit_s = int_value
		FROM dbo.Parameters
		WHERE parameter = 'FragCollectionTimeLimitS'

	--Fill tasks table

	DECLARE DB CURSOR FORWARD_ONLY
	FOR 
	SELECT database_id 
	FROM dbo.GetDbList(@use_system_db, @use_user_db, @dbname_list, @except_list) t

	OPEN DB

	FETCH NEXT FROM DB INTO @dbint_id

	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF @indexes = 1 
			IF @async_frag_collection = 0
				EXEC [dbo].[FillQueueIndex] @dbint_id, @batch, @ix_maxdop, @sortintempdb
			ELSE 
				BEGIN
					DELETE
					FROM dbo.Tasks
					WHERE subsystem_id = 1
					AND date_completed IS NULL
					AND [database_id] = @dbint_id
					
				IF @collect_frag_now = 2
					BEGIN
					EXEC [dbo].[FillQueueIndex_async] @dbint_id,@batch,@ix_maxdop,@sortintempdb 
					END
				ELSE
				EXEC [dbo].[CollectIndexData] @dbint_id, @batch
				IF @collect_frag_now = 1
					BEGIN 
						EXEC [dbo].[CollectIndexFragData] @dbint_id,@frag_collection_time_limit_s,@batch,@ix_maxdop,@sortintempdb
						--EXEC [dbo].[FillQueueIndex_async] @dbint_id,@batch,@ix_maxdop,@sortintempdb
					END
				IF @collect_frag_now = 0
				PRINT 'Index frag data needs to be collected in a separate session according to @collect_frag_now = 0. 
				Collect frag data by running  dbo.CollectIndexFragData (may be run in several parallel sessions) and rerun FillQueueAll with @async_frag_collection = 1 and @collect_frag_now = 1'	
			END

		IF ((@checkall = 1 or @checktable = 1) and @checktable <> 0)
			EXEC [dbo].[FillQueueCheckTable] @dbint_id, @batch, @table_max_size_mb

		IF ((@checkall = 1 or @checkcatalog = 1 ) and @checkcatalog <> 0) 
			EXEC [dbo].[FillQueueCheckCatalog] @dbint_id, @batch

		IF ((@checkall = 1 or @checkalloc = 1) and @checkalloc <> 0)
			EXEC [dbo].[FillQueueCheckAlloc] @dbint_id, @batch

		IF (@stats = 1)
			EXEC [dbo].[FillQueueStat] @dbint_id, @batch, @sample = @stats_sample

		FETCH NEXT FROM DB INTO @dbint_id
	END

	CLOSE DB
	DEALLOCATE DB

	--Calculate the expected execution time

	DECLARE TASKS CURSOR
	FOR SELECT entry_id, [database_id], table_id,index_id,partition_n,subsystem_id, action_type_id
	FROM dbo.Tasks WHERE time_prognosis_s is null

	OPEN TASKS

	FETCH NEXT FROM TASKS
	INTO @entryid, @db, @tableid, @indexid, @partitionnum, @subsystem_id, @actiontype

	WHILE @@FETCH_STATUS = 0 
	BEGIN 

		UPDATE dbo.Tasks
		SET time_prognosis_s = ISNULL(dbo.GetTimeFactor(@db,1, @tableid, @indexid, @partitionnum, @subsystem_id, @actiontype, 60, 1), 0) * size_mb
		WHERE entry_id = @entryid

		FETCH NEXT FROM TASKS
		INTO @entryid, @db, @tableid, @indexid, @partitionnum, @subsystem_id, @actiontype

	END

	CLOSE TASKS

	DEALLOCATE TASKS

	UPDATE dbo.Workers
		SET latched_spid = 0
		WHERE worker_name = @worker_name

	SELECT @batch as BatchId


--Удаление старых записей / Removing old records
IF EXISTS (SELECT 1 FROM dbo.Parameters WHERE parameter = 'HistoryRetentionDays' and int_value is not null )
	SELECT @retention = dateadd(DD,-int_value,getdate()) 
	FROM dbo.Parameters
	WHERE parameter = 'HistoryRetentionDays'

IF EXISTS (SELECT 1 FROM dbo.Parameters WHERE parameter = 'HistoryRetentionDays' and int_value is not null )
BEGIN
	DELETE FROM dbo.Tasks
	WHERE date_added < @retention

	DELETE FROM dbo.DBCCChecksLog
	WHERE log_date < @retention

	DELETE FROM dbo.FragmentationData
	WHERE collection_date < @retention
END
DELETE FROM dbo.WorkerSessions where worker_name = @worker_name and subsystem_id = 0

END
GO
DECLARE @Ops TABLE ([subsystem_id] int, [action_type_id]int, [subsystem_name] nvarchar(255), [action_type_name] nvarchar(255))
DECLARE @Params TABLE ([parameter] nvarchar(50), [string_value] nvarchar(150), [int_value] BIGINT, [float_value] FLOAT (53), [description] NVARCHAR (MAX) )

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (0, 1, N'Queue Generation', N'Generation of tasks for further execution')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (1, 1, N'Index Maintenance\Обслуживание индексов', N'Offline rebuild\Перестройка индекса оффлайн')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (1, 2, N'Index Maintenance\Обслуживание индексов', N'Online rebuild\Перестройка индекса онлайн')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (1, 3, N'Index Maintenance\Обслуживание индексов', N'Reorganize\Реорганизация индекса')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (2, 1, N'Statistics maintenance\Обслуживание статистики', N'Update statistics\Пересчёт статистки')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (3, 1, N'Integrity check\Проверка целостности', N'CHECKCATALOG\Проверка целостности системного каталога')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (3, 2, N'Integrity check\Проверка целостности', N'CHECKALLOC\Проверка целостности в части размещения (DBCC CHECKALLOC)')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (3, 3, N'Integrity check\Проверка целостности', N'CHECKTABLE\Проверка целостности отдельной таблицы')


INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckTableIntervalDays', NULL, 7, NULL, N'Days between CHECKTABLE\Периодичность проверки целостности отдельно взятой таблицы')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'MaxDop', NULL, 2, NULL, N'Max Degree of parallelism for index operations\Количество ядер, которые могут быть использованы для операций с индексами')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckCatalogIntervalDays', NULL, 7, NULL, N'Days between CHECKCATALOG\Периодичность проверки целостности системных таблиц БД')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'HistoryRetentionDays', NULL, 90, NULL, N'Old tasks will be removed after this number of days\Продолжительность хранения журнала заданий')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexReorgThresholdPercent', NULL, 30, NULL, N'Maximum index fragmentation when reorganize is prefered instead of rebuild\Максимальное значение фрагментации индекса для использования REORGANIZE')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexOnlineRebuild', NULL, 1, NULL, N'Use or not ONLINE where possible. Online operations are slower\Флаг использования ONLINE при перестройке индексов. Его использование увеличивает продолжительность операции, но сохраняет индекс доступным по время обслуживания')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'TotalMaintenanceWindowMm', NULL, 60, NULL, N'Total amount of time (minutes) for maintenance\Общая продолжительность технологического окна в минутах')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexMaintenanceWindowPercent', NULL, 30, NULL, N'Percent of time to spend on index maintenance\Процент времени, отведённого под обслуживание индексов')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'StatMaintenanceWindowPercent', NULL, 30, NULL, N'Percent of time to spend on statistics maintenance\ Процент времени, отведённого под обслуживание статистики')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckWindowPercent', NULL, 30, NULL, N'Percent of time to spend on integrity checks\Процент времени, отведённого под проверку целостности')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckAllocIntervalDays', NULL, 7, NULL, N'Days between CHECKALLOC\Периодичность проверки целостноси в части аллокации экстентов')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'LockTimeoutMs', NULL,20000 , NULL, N'How long (ms) should index operation wait being locked\Максимальное время в заблокированном состоянии. При превышении задание будет остановлено.')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'SortInTempdb', NULL,0 , NULL, N'Should indexes be sorted in tempdb during index rebuild?\Использование tempdb для сортировки индекса во время перестройки')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexFragLowerThreshold', NULL,10 , NULL, N'Index fragmentation lower limit. Index with fragmentation lower than this wont be maintaintes \ Нижняя граница фрагментации. Индекс с меньшей фрагментацией обслуживаться не будет')
INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'TranLogSpaceThresholdMb', NULL,500 , NULL, N'Transaction log space left threshold(mountpoints not supported yet)/Минимальный размер свободного места под лог транзакций для операций обслуживания индексов (mountpoint не поддерживается пока)')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexMinimumSizeMB', NULL,10 , NULL, N'Minimum size of index that can be rebuilt or reorganized/Минимальный размер индекса, подлежащего обслуживанию')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'FragCollectionTimeLimitS', NULL,3600 , NULL, N'Maximum duration of index fragmentation analysis phase/Максимальная продолжительность фазы анализа фрагментации индексов')

MERGE dbo.Parameters as TARGET
USING (SELECT * FROM @Params) as SOURCE ([parameter], [string_value], [int_value], [float_value], [description])
ON (TARGET.parameter COLLATE DATABASE_DEFAULT = SOURCE.parameter COLLATE DATABASE_DEFAULT)
WHEN MATCHED THEN UPDATE SET description = SOURCE.description
WHEN NOT MATCHED THEN INSERT ([parameter], [string_value], [int_value], [float_value], [description])
VALUES (SOURCE.[parameter], SOURCE.[string_value], SOURCE.[int_value], SOURCE.[float_value], SOURCE.[description]);



MERGE dbo.OperationTypes as TARGET
USING (SELECT * FROM @Ops) as SOURCE ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name])
ON (TARGET.subsystem_id = SOURCE.subsystem_id and TARGET.action_type_id = SOURCE.action_type_id)

WHEN MATCHED THEN UPDATE SET subsystem_name = SOURCE.subsystem_name, action_type_name = SOURCE.action_type_name
WHEN NOT MATCHED THEN INSERT ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name])
VALUES (SOURCE.[subsystem_id], SOURCE.[action_type_id], SOURCE.[subsystem_name], SOURCE.[action_type_name]);



INSERT dbo.DbVersion (Version,DateInstalled) VALUES ('2.0.2.3 Beta',getdate())
GO

UPDATE VBMS.dbo.Tasks 
SET exit_code = -1
WHERE result = 'Skipped. Not enough time left'
and exit_code is null


/*

changelog:
2.0.2.3b
	- FIX - afterparty does not work. at all. Old stupid typo.
	- dbo.StartWorker - added NOCOUNT ON.

2.0.2.2b
	- Added view dbo.FragAnalysisStatus to view statistics of framentation analysis tasks
	- Added support of creating blacklist items for a specific workers.
	- FIX - apriori timefactors too high 
	- FIX - time_prognosis_s column type changed to bigint to avoid overflow 
	- Tables with 0 records are excluded from checks
	- FillQueue is now managed as a worker
	- FillQueue - frag collection tasks now support LOCK_TIMEOUT feature to avoid hanging on frag collection
	- FIllQueue - frag collection now supports blacklists

*/
GO

GO
PRINT N'Update complete.';


GO
