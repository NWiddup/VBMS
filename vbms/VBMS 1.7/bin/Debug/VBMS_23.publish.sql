/*
Deployment script for VBMS

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "VBMS"
:setvar DefaultFilePrefix "VBMS"
:setvar DefaultDataPath "C:\SQL\MSSQL13.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\SQL\MSSQL13.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'disable';


GO
PRINT N'Altering [dbo].[FillQueueIndex_async]...';


GO
/*

-- THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED "AS IS" WITHOUT
--WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
--LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
--FOR A PARTICULAR PURPOSE.

Author: 
Oleg Trutnev otrutnev@microsoft.com
Arseny Birukov arsbir@microsoft.com


Russian:

Процедура формирования заданий обслуживания индексов на основе их состояния. 
Задания - выражения для обслуживания отдельных индексов - добавляются в таблицу dbo.Tasks
Применяется оценка процента фрагментации и возможности перестройки индекса онлайн.
Для приоритезации заданий используется частота обращений к индексу (только user_scan), фрагментация и размер индекса.  

English:

Stored procedure creates tasks for index maintenance based on their state and operational stats.
Tasks are T-SQL statements of index REBUILD/REORGANIZE, that are inserted in dbo.Tasks table.
Index is evaluated by frag percent, user scans counter and size. 
First goes the most used (user scans) index with higher fragmentation and the larger size.   

 
*/

ALTER PROCEDURE [dbo].[FillQueueIndex_async] 
	 @db INT
	,@batch UNIQUEIDENTIFIER
	,@maxdop INT = NULL
	,@sortintempdb BIT = NULL
	,@entry_id bigint = NULL
AS



DECLARE
	@reorg_threshold decimal(10,3),
	@frag_threshold bigint,
	@locktimeout bigint,
	@online_allowed bit,
	@SQL nvarchar(max),
	@index_minsize bigint
	
DECLARE @worker_name nvarchar(255)
SELECT @worker_name = worker_name
FROM dbo.WorkerSessions
WHERE session_id = @@SPID


--Считываем параметры / Loading parameters
SELECT @reorg_threshold = int_value
FROM dbo.Parameters
WHERE parameter = 'IndexReorgThresholdPercent'

SELECT @locktimeout = int_value
FROM dbo.Parameters
WHERE parameter = 'LockTimeoutMs'

SELECT @frag_threshold = int_value
FROM dbo.Parameters
WHERE parameter = 'IndexFragLowerThreshold'


SELECT @index_minsize = int_value
FROM dbo.Parameters
WHERE parameter = 'IndexMinimumSizeMB'

IF @maxdop is null
SELECT @maxdop = int_value
		FROM dbo.Parameters
		WHERE parameter = 'MaxDop'

IF @sortintempdb IS NULL
		SELECT @sortintempdb= int_value
		FROM dbo.Parameters
		WHERE parameter = 'SortInTempdb'


IF (CAST(SERVERPROPERTY('Edition') as NVARCHAR(50)) LIKE N'%Enterprise%'
  OR CAST(SERVERPROPERTY('Edition') as NVARCHAR(50)) LIKE N'%Datacenter%'
  OR CAST(SERVERPROPERTY('Edition') as NVARCHAR(50)) LIKE N'%Developer%')
	SELECT @online_allowed = int_value
	FROM dbo.Parameters
	WHERE parameter = 'IndexOnlineRebuild'
ELSE 
	SET @online_allowed = 0
	

IF OBJECT_ID('tempdb..#partitions') is not null
	DROP TABLE #partitions

CREATE TABLE #partitions
(
	database_id int, 
	schema_id int,  
	object_id int, 
	object_name nvarchar(4000),
	index_id int,
	index_name nvarchar(4000),
	volume_mount_point nvarchar(255),
	allow_page_locks bit,
	legacy_col_count int,
	xml_col_count int,
	user_scans bigint,
	partition_count int,
	partition_number int,
	row_count bigint,
	size_mb decimal(10,3),
	avg_fragmentation_in_percent decimal(10,3)
)

INSERT INTO #partitions
SELECT 
database_id,
schema_id,
object_id,
object_name,
index_id,
index_name,
volume_mount_point,
allow_page_locks,
legacy_col_count,
xml_col_count,
user_scans,
partition_count,
partition_number,
row_count,
size_mb,
avg_fragmentation_in_percent
FROM
[dbo].[FragmentationData] with (FORCESEEK)
WHERE
(entry_id = @entry_id
OR
(@entry_id is NULL and 
database_id = @db
and analysis_status = 1))
AND avg_fragmentation_in_percent > @frag_threshold



INSERT dbo.Tasks (
	batch_id
	,subsystem_id
	,action_type_id
	,command
	,date_added
	,[database_id]
	,table_id
	,index_id
	,partition_n
	,[maxdop]
	,ix_frag
	,user_seeks
	,user_scans
	,user_updates
	,rowcnt
	,size_mb
	,[priority]
	,volume_mount_point
)
SELECT
	@batch,
	1,  --index maintenance
	t.action_type_id,
	t.command,
	getdate(),
	@db,
	t.object_id,
	t.index_id,
	t.partition_number,
	t.maxdop,
	t.avg_fragmentation_in_percent,
	NULL, --removed seeks - useless
	t.user_scans,
	NULL, --removed updates
	t.row_count,
	t.size_mb,
	CASE WHEN ISNULL(pt.exit_code,1) <> 1 THEN 2 ELSE 1 END --Если предыдущий таск завершился с ошибкой понижаем этму приоритет
	,t.volume_mount_point
FROM
	(
		SELECT
			CASE 
				WHEN t.action = N'REBUILD' AND t.online LIKE N'OFF%' THEN 1
				WHEN t.action = N'REBUILD' AND t.online is null THEN 1
				WHEN t.action = N'REBUILD' AND t.online LIKE N'ON%' THEN 2
				WHEN t.action = N'REORGANIZE' THEN 3
			END as action_type_id,
			--Конструирую выражение / Assembling statement
			N'USE ' + QUOTENAME(DB_NAME(@db)) + N'; ' +
			CASE WHEN @locktimeout<60000 or (@@MicrosoftVersion/0x01000000)<12 THEN N'SET LOCK_TIMEOUT ' + t.lock_timeout + N'; ' ELSE '' END +
			N'ALTER INDEX [' + t.index_name + N'] ON '+ t.object_name + N' ' + t.action + N' ' + t.partition_spec +
			CASE WHEN t.action = N'REBUILD' THEN N'WITH ('+COALESCE('ONLINE='+ t.online,'') +N'SORT_IN_TEMPDB='+ t.sort_in_tempdb + N'MAXDOP='+ t.maxdop + N')' ELSE N'' END + N';' --rebuild options
			as command,
			*
		FROM
			(	--Подготавливаю опции / prepare options for the statement
				SELECT 
					--REORG or REBUILD:
					CASE WHEN avg_fragmentation_in_percent > @reorg_threshold THEN N'REBUILD' ELSE N'REORGANIZE' END as [action],
					--If we have multiple partitions, specify the partition number
					CASE WHEN partition_count > 1 THEN N' PARTITION = ' + CAST(partition_number as nvarchar(10)) ELSE N'' END + N' ' as partition_spec,
					--Sort in tempdb determined by global option
					CASE WHEN @sortintempdb = 1 THEN N'ON, ' ELSE N'OFF, ' END [sort_in_tempdb],
					--If possible, perform online rebuild
					CASE 
						WHEN @online_allowed = 0 THEN N'OFF, /*disabled*/ '  --online is disabled in settings
						WHEN legacy_col_count > 0 THEN N'OFF, /*legacy*/ ' --legacy column types can't be rebuilt online
						WHEN xml_col_count > 0 AND (@@MicrosoftVersion/0x01000000)<11 THEN N'OFF, /*xml*/ ' --xml columns can't be rebuild online prior to 2012
						--WHEN partition_count = 1 THEN NULL --one partition can't be rebuild online and even OFF is incorrect
						WHEN partition_count > 1 AND (@@MicrosoftVersion/0x01000000)<12 THEN NULL --prior to SQL 2014 partitions could not be rebuilt online and even OFF is incorrect
						ELSE --We can use online rebuild
							CASE 
							--Starting from 2014 rebuild can wait at low priority:
								WHEN (@@MicrosoftVersion/0x01000000)>=12 and @locktimeout >= 60000 /*more than a minute */ THEN N'ON (WAIT_AT_LOW_PRIORITY ( MAX_DURATION = '+cast(@locktimeout/60000 as nvarchar(20))+' , ABORT_AFTER_WAIT = SELF ) ),' 
								
								ELSE N'ON, ' --Simply online
								
								
							END

					END as [online],
					--Lock timeout from global settings
					CAST(@locktimeout as nvarchar(10)) as [lock_timeout],
					--Set maxdop if page locks are not prohibited. See  http://support.microsoft.com/kb/2292737 
					CASE 
						WHEN [allow_page_locks] = 1 OR (@@MicrosoftVersion/0x01000000)>=11  THEN  CAST(ISNULL(@maxdop,1) AS nvarchar(10))
						--WHEN @allow_pl = 0 AND (@@MicrosoftVersion/0x01000000)<11 THEN N'1' 
						ELSE N'1'
					END as [maxdop],
					*
				FROM 
					#partitions p
			) t
	) t
	OUTER APPLY --находим такой же предыдущий таск / Find similar prevous task 
	(
		SELECT TOP 1 pt.exit_code 
		FROM
			dbo.Tasks pt
		WHERE
			pt.subsystem_id = 1 
			AND pt.action_type_id = t.action_type_id
			AND pt.database_id = t.database_id
			AND pt.table_id = t.object_id
			AND pt.index_id = t.index_id
			AND pt.partition_n = t.partition_number
			AND pt.date_completed is not null
		ORDER BY
			pt.date_completed DESC
	) pt
WHERE
	--Фрагментация выше порога / Fragmentation above threshold
	NOT EXISTS	(
		SELECT 1 
		FROM dbo.Blacklist bl
		WHERE 
			bl.[database_id] = @db 
			AND (bl.table_id = t.object_id or bl.table_id is null)
			AND (bl.index_id = t.index_id or bl.index_id is null) 
			AND (bl.subsystem_id = 1 or bl.subsystem_id is null)
			AND (bl.action_type_id = t.action_type_id or bl.action_type_id is null)
			AND (bl.partition_n = t.partition_number or bl.partition_n is null)
			AND (bl.worker_name = @worker_name or worker_name is null)
			AND bl.enabled = 1
	)
ORDER BY 
	t.user_scans DESC,
	t.avg_fragmentation_in_percent DESC,
	t.size_mb DESC
GO
PRINT N'Refreshing [dbo].[FillQueueAll]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[FillQueueAll]';


GO
DECLARE @Ops TABLE ([subsystem_id] int, [action_type_id]int, [subsystem_name] nvarchar(255), [action_type_name] nvarchar(255))
DECLARE @Params TABLE ([parameter] nvarchar(50), [string_value] nvarchar(150), [int_value] BIGINT, [float_value] FLOAT (53), [description] NVARCHAR (MAX) )

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (0, 1, N'Queue Generation', N'Generation of tasks for further execution')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (1, 1, N'Index Maintenance\Обслуживание индексов', N'Offline rebuild\Перестройка индекса оффлайн')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (1, 2, N'Index Maintenance\Обслуживание индексов', N'Online rebuild\Перестройка индекса онлайн')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (1, 3, N'Index Maintenance\Обслуживание индексов', N'Reorganize\Реорганизация индекса')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (2, 1, N'Statistics maintenance\Обслуживание статистики', N'Update statistics\Пересчёт статистки')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (3, 1, N'Integrity check\Проверка целостности', N'CHECKCATALOG\Проверка целостности системного каталога')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (3, 2, N'Integrity check\Проверка целостности', N'CHECKALLOC\Проверка целостности в части размещения (DBCC CHECKALLOC)')

INSERT @Ops ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name]) VALUES (3, 3, N'Integrity check\Проверка целостности', N'CHECKTABLE\Проверка целостности отдельной таблицы')


INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckTableIntervalDays', NULL, 7, NULL, N'Days between CHECKTABLE\Периодичность проверки целостности отдельно взятой таблицы')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'MaxDop', NULL, 2, NULL, N'Max Degree of parallelism for index operations\Количество ядер, которые могут быть использованы для операций с индексами')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckCatalogIntervalDays', NULL, 7, NULL, N'Days between CHECKCATALOG\Периодичность проверки целостности системных таблиц БД')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'HistoryRetentionDays', NULL, 90, NULL, N'Old tasks will be removed after this number of days\Продолжительность хранения журнала заданий')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexReorgThresholdPercent', NULL, 30, NULL, N'Maximum index fragmentation when reorganize is prefered instead of rebuild\Максимальное значение фрагментации индекса для использования REORGANIZE')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexOnlineRebuild', NULL, 1, NULL, N'Use or not ONLINE where possible. Online operations are slower\Флаг использования ONLINE при перестройке индексов. Его использование увеличивает продолжительность операции, но сохраняет индекс доступным по время обслуживания')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'TotalMaintenanceWindowMm', NULL, 60, NULL, N'Total amount of time (minutes) for maintenance\Общая продолжительность технологического окна в минутах')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexMaintenanceWindowPercent', NULL, 30, NULL, N'Percent of time to spend on index maintenance\Процент времени, отведённого под обслуживание индексов')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'StatMaintenanceWindowPercent', NULL, 30, NULL, N'Percent of time to spend on statistics maintenance\ Процент времени, отведённого под обслуживание статистики')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckWindowPercent', NULL, 30, NULL, N'Percent of time to spend on integrity checks\Процент времени, отведённого под проверку целостности')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'CheckAllocIntervalDays', NULL, 7, NULL, N'Days between CHECKALLOC\Периодичность проверки целостноси в части аллокации экстентов')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'LockTimeoutMs', NULL,20000 , NULL, N'How long (ms) should index operation wait being locked\Максимальное время в заблокированном состоянии. При превышении задание будет остановлено.')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'SortInTempdb', NULL,0 , NULL, N'Should indexes be sorted in tempdb during index rebuild?\Использование tempdb для сортировки индекса во время перестройки')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexFragLowerThreshold', NULL,10 , NULL, N'Index fragmentation lower limit. Index with fragmentation lower than this wont be maintaintes \ Нижняя граница фрагментации. Индекс с меньшей фрагментацией обслуживаться не будет')
INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'TranLogSpaceThresholdMb', NULL,500 , NULL, N'Transaction log space left threshold(mountpoints not supported yet)/Минимальный размер свободного места под лог транзакций для операций обслуживания индексов (mountpoint не поддерживается пока)')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'IndexMinimumSizeMB', NULL,10 , NULL, N'Minimum size of index that can be rebuilt or reorganized/Минимальный размер индекса, подлежащего обслуживанию')

INSERT @Params ([parameter], [string_value], [int_value], [float_value], [description]) VALUES (N'FragCollectionTimeLimitS', NULL,3600 , NULL, N'Maximum duration of index fragmentation analysis phase/Максимальная продолжительность фазы анализа фрагментации индексов')

MERGE dbo.Parameters as TARGET
USING (SELECT * FROM @Params) as SOURCE ([parameter], [string_value], [int_value], [float_value], [description])
ON (TARGET.parameter COLLATE DATABASE_DEFAULT = SOURCE.parameter COLLATE DATABASE_DEFAULT)
WHEN MATCHED THEN UPDATE SET description = SOURCE.description
WHEN NOT MATCHED THEN INSERT ([parameter], [string_value], [int_value], [float_value], [description])
VALUES (SOURCE.[parameter], SOURCE.[string_value], SOURCE.[int_value], SOURCE.[float_value], SOURCE.[description]);



MERGE dbo.OperationTypes as TARGET
USING (SELECT * FROM @Ops) as SOURCE ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name])
ON (TARGET.subsystem_id = SOURCE.subsystem_id and TARGET.action_type_id = SOURCE.action_type_id)

WHEN MATCHED THEN UPDATE SET subsystem_name = SOURCE.subsystem_name, action_type_name = SOURCE.action_type_name
WHEN NOT MATCHED THEN INSERT ([subsystem_id], [action_type_id], [subsystem_name], [action_type_name])
VALUES (SOURCE.[subsystem_id], SOURCE.[action_type_id], SOURCE.[subsystem_name], SOURCE.[action_type_name]);



INSERT dbo.DbVersion (Version,DateInstalled) VALUES ('2.0.2.3 Beta',getdate())
GO

UPDATE VBMS.dbo.Tasks 
SET exit_code = -1
WHERE result = 'Skipped. Not enough time left'
and exit_code is null


/*

changelog:
2.0.2.3b
	- FIX - afterparty does not work. at all. Old stupid typo.
	- dbo.StartWorker - added NOCOUNT ON.

2.0.2.2b
	- Added view dbo.FragAnalysisStatus to view statistics of framentation analysis tasks
	- Added support of creating blacklist items for a specific workers.
	- FIX - apriori timefactors too high 
	- FIX - time_prognosis_s column type changed to bigint to avoid overflow 
	- Tables with 0 records are excluded from checks
	- FillQueue is now managed as a worker
	- FillQueue - frag collection tasks now support LOCK_TIMEOUT feature to avoid hanging on frag collection
	- FIllQueue - frag collection now supports blacklists

*/
GO

GO
PRINT N'Update complete.';


GO
